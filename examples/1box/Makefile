###### BENTO-BOX AUTOGENERATED ######

TARGET         ?= system.elf
CROSS_COMPILE  ?= arm-none-eabi-
DEBUG          ?= 1
LTO            ?= 1
CC             = $(CROSS_COMPILE)gcc
OBJCOPY        = $(CROSS_COMPILE)objcopy
OBJDUMP        = $(CROSS_COMPILE)objdump
AR             = $(CROSS_COMPILE)ar
SIZE           = $(CROSS_COMPILE)size
GDB            = $(CROSS_COMPILE)gdb
GDBADDR        ?= localhost
GDBPORT        ?= 3333
TTY            ?= $(firstword $(wildcard /dev/ttyACM* /dev/ttyUSB*))
BAUD           ?= 115200

SRC += .
SRC += nrfx/drivers/src

INC += .
INC += nrfx
INC += cmsis
INC += nrfx/drivers/include
INC += nrfx/mdk
INC += nrfx/templates

LIB += m
LIB += c
LIB += gcc
LIB += nosys

LDSCRIPT := $(firstword $(wildcard $(patsubst %,%/*.ld,$(SRC))))

OBJ := $(patsubst %.c,%.o,$(wildcard $(patsubst %,%/*.c,$(SRC))))
OBJ += $(patsubst %.s,%.o,$(wildcard $(patsubst %,%/*.s,$(SRC))))
OBJ += $(patsubst %.S,%.o,$(wildcard $(patsubst %,%/*.S,$(SRC))))
DEP := $(patsubst %.o,%.d,$(OBJ))
BOXES += box1/box1.box

ifneq ($(DEBUG),0)
override CFLAGS += -DDEBUG
override CFLAGS += -g
override CFLAGS += -O0
else
override CFLAGS += -DNDEBUG
override CFLAGS += -Os
ifneq ($(LTO),0)
override CFLAGS += -flto
endif
endif
override CFLAGS += -mthumb
override CFLAGS += -mcpu=cortex-m4
override CFLAGS += -mfpu=fpv4-sp-d16
override CFLAGS += -mfloat-abi=softfp
override CFLAGS += -std=c99
override CFLAGS += -Wall -Wno-format
override CFLAGS += -fno-common
override CFLAGS += -ffunction-sections
override CFLAGS += -fdata-sections
override CFLAGS += -ffreestanding
override CFLAGS += -fno-builtin
override CFLAGS += $(patsubst %,-I%,$(INC))

override ASMFLAGS += $(CFLAGS)

override LFLAGS += $(CFLAGS)
override LFLAGS += -T$(LDSCRIPT)
override LFLAGS += -Wl,--start-group $(patsubst %,-l%,$(LIB)) -Wl,--end-group
override LFLAGS += -static
override LFLAGS += --specs=nano.specs
override LFLAGS += --specs=nosys.specs
override LFLAGS += -Wl,--gc-sections
override LFLAGS += -Wl,-static
override LFLAGS += -Wl,-z,muldefs

### __box_abort glue ###

override LFLAGS += -Wl,--wrap,abort

### __box_write glue ###

override LFLAGS += -Wl,--wrap,printf

override LFLAGS += -Wl,--wrap,vprintf

override LFLAGS += -Wl,--wrap,fprintf

override LFLAGS += -Wl,--wrap,vfprintf

override LFLAGS += -Wl,--wrap,fflush

### user provided flags ###

override CFLAGS += -DNRF52840_XXAA=1
override CFLAGS += -DNRFX_UARTE0_ENABLED=1
override CFLAGS += -DNRFX_UARTE_ENABLED=1

### rules ###

# default rule
.PHONY: all build
all build: $(TARGET)

# computing size size is a bit complicated as each .elf includes its boxes, we
# want independent sizes.
.PHONY: size
size: $(TARGET)
	$(strip ( $(SIZE) $< ;\
	    $(MAKE) -s --no-print-directory -C box1 size ) | awk '\
	        function f(t, d, b, n) {printf \
	            "%7d %7d %7d %7d %7x %s\n", \
	            t, d, b, t+d+b, t+d+b, n} \
	        NR==1 {print} \
	        NR==2 {t=$$1; d=$$2; b=$$3; n=$$6} \
	        NR>3 && /^([ \t]+[0-9]+){3,}/ && !/TOTALS/ { \
	           l[NR-4]=$$0; t-=$$1+$$2; b-=$$3+$$2; \
	           tt+=$$1; td+=$$2; tb+=$$3} \
	        END {f(t, d, b, n)} \
	        END {for (i in l) print l[i]} \
	        END {f(t+tt, d+td, b+tb, "(TOTALS)")}')

.PHONY: debug
debug: $(TARGET)
	echo '$$qRcmd,68616c74#fc' | nc -N $(GDBADDR) $(GDBPORT) && echo # halt
	$(strip $(GDB) $< \
	    -ex "target remote $(GDBADDR):$(GDBPORT)")
	echo '$$qRcmd,676f#2c' | nc -N $(GDBADDR) $(GDBPORT) && echo # go

.PHONY: flash
flash: $(TARGET)
	echo '$$qRcmd,68616c74#fc' | nc -N $(GDBADDR) $(GDBPORT) && echo # halt
	$(strip $(GDB) $< \
	    -ex "target remote $(GDBADDR):$(GDBPORT)" \
	    -ex "load" \
	    -ex "monitor reset" \
	    -batch)

.PHONY: reset
reset:
	echo '$$qRcmd,7265736574#37' | nc -N $(GDBADDR) $(GDBPORT) && echo # reset
	echo '$$qRcmd,676f#2c' | nc -N $(GDBADDR) $(GDBPORT) && echo # go

.PHONY: cat
cat:
	stty -F $(TTY) sane nl $(BAUD)
	cat $(TTY)

.PHONY: tags
tags:
	$(strip ctags \
	    $(wildcard $(patsubst %,%/*.c,$(SRC))) \
	    $(wildcard $(patsubst %,%/*.s,$(SRC))) \
	    $(wildcard $(patsubst %,%/*.S,$(SRC))))

.PHONY: $(shell make -s -C box1 box1.box -q || echo box1/box1.box)
box1/box1.box:
	@echo "================= make -C box1 ================="
	$(MAKE) --no-print-directory -C box1 box1.box
	@echo "================================================"

# target rule
$(TARGET): $(OBJ) $(BOXES) $(LDSCRIPT)
	$(CC) $(OBJ) $(BOXES) $(LFLAGS) -o $@

# header dependencies
-include $(DEP)

# a .box is a .elf stripped, with sections prefixed by the names of the
# allocated memory regions
%.box: %.elf %.box.data
	$(strip $(OBJCOPY) $< $@ \
	    --strip-all \
	    --add-section .box.system.flash.data=$(word 2,$^) \
	    --only-section .text \
	    --rename-section .text=.box.system.flash.text \
	    --only-section .isr_vector \
	    --rename-section .isr_vector=.box.system.flash.isr_vector \
	    --only-section .stack \
	    --rename-section .stack=.box.system.ram.stack \
	    --only-section .data \
	    --rename-section .data=.box.system.ram.data \
	    --only-section .bss \
	    --rename-section .bss=.box.system.ram.bss \
	    --only-section .heap \
	    --rename-section .heap=.box.system.ram.heap)

%.box.data: %.elf
	$(OBJCOPY) $< $@ -O binary -j .data

%.bin: %.elf
	$(OBJCOPY) -O binary $< $@

%.o: %.c
	$(CC) -c -MMD -MP $(CFLAGS) $< -o $@

%.s: %.c
	$(CC) -S -MMD -MP $(CFLAGS) $< -o $@

%.o: %.s
	$(CC) -c -MMD -MP $(ASMFLAGS) $< -o $@

%.o: %.S
	$(CC) -c -MMD -MP $(ASMFLAGS) $< -o $@

.PHONY: clean
clean:
	rm -f $(TARGET) $(BOXES)
	rm -f $(OBJ)
	rm -f $(DEP)
	$(MAKE) -C box1 clean

