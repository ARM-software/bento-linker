////// AUTOGENERATED //////
#![no_std]
use core::convert::TryFrom;
use core::fmt;
use core::num;
use core::panic;
use core::result;

extern crate bento_macros;
pub use bento_macros::export;

pub mod import {
    #[allow(unused_imports)]
    use core::{convert::TryFrom, ptr, slice};
    #[allow(unused_imports)]
    use crate::{Result, Error};
}

pub mod export {
    #[allow(unused_imports)]
    use bento_macros::export_export;

    #[export_export(type=fn(a0: i32, a1: i32) -> __box_exports::Result<u32>)]
    pub fn boxrust_add2(a0: i32, a1: i32) -> i32 {
        #[allow(unused_imports)]
        use core::{convert::TryFrom, ptr, slice};
        #[allow(unused_imports)]
        use __box_exports::{Result, Error};
        let r0 = __box_export_boxrust_add2(a0, a1);
        let r0 = match r0 {
            Ok(x) => i32::try_from(x).unwrap(),
            Err(err) => -err.get_i32(),
        };
        r0
    }

    #[export_export(type=fn(buffer: &mut [u32], a: u32, b: u32) -> __box_exports::Result<()>)]
    pub fn boxrust_fib(buffer: *mut u32, size: usize, a: u32, b: u32) -> i32 {
        #[allow(unused_imports)]
        use core::{convert::TryFrom, ptr, slice};
        #[allow(unused_imports)]
        use __box_exports::{Result, Error};
        let buffer = unsafe { slice::from_raw_parts_mut(buffer, size) };
        let r0 = __box_export_boxrust_fib(buffer, a, b);
        let r0 = match r0 {
            Ok(()) => 0,
            Err(err) => -err.get_i32(),
        };
        r0
    }

    #[export_export(type=fn(size: usize) -> Option<&'static mut u8>)]
    pub fn boxrust_fib_alloc(size: usize) -> *mut u8 {
        #[allow(unused_imports)]
        use core::{convert::TryFrom, ptr, slice};
        #[allow(unused_imports)]
        use __box_exports::{Result, Error};
        let r0 = __box_export_boxrust_fib_alloc(size);
        let r0 = match r0 {
            Some(r0) => {
                let r0 = r0 as *mut u8;
                r0
            },
            None => ptr::null_mut(),
        };
        r0
    }

    #[export_export(type=fn(next: &mut u32, a: u32, b: u32) -> __box_exports::Result<()>)]
    pub fn boxrust_fib_next(next: *mut u32, a: u32, b: u32) -> i32 {
        #[allow(unused_imports)]
        use core::{convert::TryFrom, ptr, slice};
        #[allow(unused_imports)]
        use __box_exports::{Result, Error};
        let next = unsafe { &mut *next };
        let r0 = __box_export_boxrust_fib_next(next, a, b);
        let r0 = match r0 {
            Ok(()) => 0,
            Err(err) => -err.get_i32(),
        };
        r0
    }

    #[export_export(type=fn() -> __box_exports::Result<()>)]
    pub fn boxrust_hello() -> i32 {
        #[allow(unused_imports)]
        use core::{convert::TryFrom, ptr, slice};
        #[allow(unused_imports)]
        use __box_exports::{Result, Error};
        let r0 = __box_export_boxrust_hello();
        let r0 = match r0 {
            Ok(()) => 0,
            Err(err) => -err.get_i32(),
        };
        r0
    }

    #[export_export(type=fn(buffer: &mut [u32]) -> __box_exports::Result<()>)]
    pub fn boxrust_qsort(buffer: *mut u32, size: usize) -> i32 {
        #[allow(unused_imports)]
        use core::{convert::TryFrom, ptr, slice};
        #[allow(unused_imports)]
        use __box_exports::{Result, Error};
        let buffer = unsafe { slice::from_raw_parts_mut(buffer, size) };
        let r0 = __box_export_boxrust_qsort(buffer);
        let r0 = match r0 {
            Ok(()) => 0,
            Err(err) => -err.get_i32(),
        };
        r0
    }

    #[export_export(type=fn(size: usize) -> Option<&'static mut u8>)]
    pub fn boxrust_qsort_alloc(size: usize) -> *mut u8 {
        #[allow(unused_imports)]
        use core::{convert::TryFrom, ptr, slice};
        #[allow(unused_imports)]
        use __box_exports::{Result, Error};
        let r0 = __box_export_boxrust_qsort_alloc(size);
        let r0 = match r0 {
            Some(r0) => {
                let r0 = r0 as *mut u8;
                r0
            },
            None => ptr::null_mut(),
        };
        r0
    }

    #[export_export(type=fn(buffer: &mut [u32], pivot: u32) -> __box_exports::Result<usize>)]
    pub fn boxrust_qsort_partition(buffer: *mut u32, size: usize, pivot: u32) -> isize {
        #[allow(unused_imports)]
        use core::{convert::TryFrom, ptr, slice};
        #[allow(unused_imports)]
        use __box_exports::{Result, Error};
        let buffer = unsafe { slice::from_raw_parts_mut(buffer, size) };
        let r0 = __box_export_boxrust_qsort_partition(buffer, pivot);
        let r0 = match r0 {
            Ok(x) => isize::try_from(x).unwrap(),
            Err(err) => isize::try_from(-err.get_i32()).unwrap(),
        };
        r0
    }
}

/// Error type, internally wraps a u31
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Error(num::NonZeroU32);

impl Error {
    pub const unsafe fn new_unchecked(code: u32) -> Self {
        Self(num::NonZeroU32::new_unchecked(code))
    }

    pub fn new(code: u32) -> Option<Self> {
        if code < 2u32.pow(31) {
            Some(Self(num::NonZeroU32::new(code)?))
        } else {
            None
        }
    }

    pub const fn get(self) -> u32 {
        self.0.get()
    }

    /// Error codes are 31-bit values, so we can convert to
    /// an i32 safely
    pub const fn get_i32(self) -> i32 {
        self.0.get() as i32
    }
}

impl Default for Error {
    fn default() -> Self {
        Self::GENERAL
    }
}

impl Error {
    /// General error
    pub const GENERAL          : Error = unsafe { Error::new_unchecked(1) };
    /// No such file or directory
    pub const NOENT            : Error = unsafe { Error::new_unchecked(2) };
    /// No such process
    pub const SRCH             : Error = unsafe { Error::new_unchecked(3) };
    /// Interrupted system call
    pub const INTR             : Error = unsafe { Error::new_unchecked(4) };
    /// I/O error
    pub const IO               : Error = unsafe { Error::new_unchecked(5) };
    /// No such device or address
    pub const NXIO             : Error = unsafe { Error::new_unchecked(6) };
    /// Argument list too long
    pub const TOOBIG           : Error = unsafe { Error::new_unchecked(7) };
    /// Exec format error
    pub const NOEXEC           : Error = unsafe { Error::new_unchecked(8) };
    /// Bad file number
    pub const BADF             : Error = unsafe { Error::new_unchecked(9) };
    /// No child processes
    pub const CHILD            : Error = unsafe { Error::new_unchecked(10) };
    /// Try again
    pub const AGAIN            : Error = unsafe { Error::new_unchecked(11) };
    /// Out of memory
    pub const NOMEM            : Error = unsafe { Error::new_unchecked(12) };
    /// Permission denied
    pub const ACCES            : Error = unsafe { Error::new_unchecked(13) };
    /// Bad address
    pub const FAULT            : Error = unsafe { Error::new_unchecked(14) };
    /// Device or resource busy
    pub const BUSY             : Error = unsafe { Error::new_unchecked(16) };
    /// File exists
    pub const EXIST            : Error = unsafe { Error::new_unchecked(17) };
    /// Cross-device link
    pub const XDEV             : Error = unsafe { Error::new_unchecked(18) };
    /// No such device
    pub const NODEV            : Error = unsafe { Error::new_unchecked(19) };
    /// Not a directory
    pub const NOTDIR           : Error = unsafe { Error::new_unchecked(20) };
    /// Is a directory
    pub const ISDIR            : Error = unsafe { Error::new_unchecked(21) };
    /// Invalid argument
    pub const INVAL            : Error = unsafe { Error::new_unchecked(22) };
    /// File table overflow
    pub const NFILE            : Error = unsafe { Error::new_unchecked(23) };
    /// Too many open files
    pub const MFILE            : Error = unsafe { Error::new_unchecked(24) };
    /// Not a typewriter
    pub const NOTTY            : Error = unsafe { Error::new_unchecked(25) };
    /// Text file busy
    pub const TXTBSY           : Error = unsafe { Error::new_unchecked(26) };
    /// File too large
    pub const FBIG             : Error = unsafe { Error::new_unchecked(27) };
    /// No space left on device
    pub const NOSPC            : Error = unsafe { Error::new_unchecked(28) };
    /// Illegal seek
    pub const SPIPE            : Error = unsafe { Error::new_unchecked(29) };
    /// Read-only file system
    pub const ROFS             : Error = unsafe { Error::new_unchecked(30) };
    /// Too many links
    pub const MLINK            : Error = unsafe { Error::new_unchecked(31) };
    /// Broken pipe
    pub const PIPE             : Error = unsafe { Error::new_unchecked(32) };
    /// Math argument out of domain of func
    pub const DOM              : Error = unsafe { Error::new_unchecked(33) };
    /// Math result not representable
    pub const RANGE            : Error = unsafe { Error::new_unchecked(34) };
    /// Resource deadlock would occur
    pub const DEADLK           : Error = unsafe { Error::new_unchecked(35) };
    /// File name too long
    pub const NAMETOOLONG      : Error = unsafe { Error::new_unchecked(36) };
    /// No record locks available
    pub const NOLCK            : Error = unsafe { Error::new_unchecked(37) };
    /// Function not implemented
    pub const NOSYS            : Error = unsafe { Error::new_unchecked(38) };
    /// Directory not empty
    pub const NOTEMPTY         : Error = unsafe { Error::new_unchecked(39) };
    /// Too many symbolic links encountered
    pub const LOOP             : Error = unsafe { Error::new_unchecked(40) };
    /// No message of desired type
    pub const NOMSG            : Error = unsafe { Error::new_unchecked(42) };
    /// Identifier removed
    pub const IDRM             : Error = unsafe { Error::new_unchecked(43) };
    /// Device not a stream
    pub const NOSTR            : Error = unsafe { Error::new_unchecked(60) };
    /// No data available
    pub const NODATA           : Error = unsafe { Error::new_unchecked(61) };
    /// Timer expired
    pub const TIME             : Error = unsafe { Error::new_unchecked(62) };
    /// Out of streams resources
    pub const NOSR             : Error = unsafe { Error::new_unchecked(63) };
    /// Link has been severed
    pub const NOLINK           : Error = unsafe { Error::new_unchecked(67) };
    /// Protocol error
    pub const PROTO            : Error = unsafe { Error::new_unchecked(71) };
    /// Multihop attempted
    pub const MULTIHOP         : Error = unsafe { Error::new_unchecked(72) };
    /// Not a data message
    pub const BADMSG           : Error = unsafe { Error::new_unchecked(74) };
    /// Value too large for defined data type
    pub const OVERFLOW         : Error = unsafe { Error::new_unchecked(75) };
    /// Illegal byte sequence
    pub const ILSEQ            : Error = unsafe { Error::new_unchecked(84) };
    /// Socket operation on non-socket
    pub const NOTSOCK          : Error = unsafe { Error::new_unchecked(88) };
    /// Destination address required
    pub const DESTADDRREQ      : Error = unsafe { Error::new_unchecked(89) };
    /// Message too long
    pub const MSGSIZE          : Error = unsafe { Error::new_unchecked(90) };
    /// Protocol wrong type for socket
    pub const PROTOTYPE        : Error = unsafe { Error::new_unchecked(91) };
    /// Protocol not available
    pub const NOPROTOOPT       : Error = unsafe { Error::new_unchecked(92) };
    /// Protocol not supported
    pub const PROTONOSUPPORT   : Error = unsafe { Error::new_unchecked(93) };
    /// Operation not supported on transport endpoint
    pub const OPNOTSUPP        : Error = unsafe { Error::new_unchecked(95) };
    /// Address family not supported by protocol
    pub const AFNOSUPPORT      : Error = unsafe { Error::new_unchecked(97) };
    /// Address already in use
    pub const ADDRINUSE        : Error = unsafe { Error::new_unchecked(98) };
    /// Cannot assign requested address
    pub const ADDRNOTAVAIL     : Error = unsafe { Error::new_unchecked(99) };
    /// Network is down
    pub const NETDOWN          : Error = unsafe { Error::new_unchecked(100) };
    /// Network is unreachable
    pub const NETUNREACH       : Error = unsafe { Error::new_unchecked(101) };
    /// Network dropped connection because of reset
    pub const NETRESET         : Error = unsafe { Error::new_unchecked(102) };
    /// Software caused connection abort
    pub const CONNABORTED      : Error = unsafe { Error::new_unchecked(103) };
    /// Connection reset by peer
    pub const CONNRESET        : Error = unsafe { Error::new_unchecked(104) };
    /// No buffer space available
    pub const NOBUFS           : Error = unsafe { Error::new_unchecked(105) };
    /// Transport endpoint is already connected
    pub const ISCONN           : Error = unsafe { Error::new_unchecked(106) };
    /// Transport endpoint is not connected
    pub const NOTCONN          : Error = unsafe { Error::new_unchecked(107) };
    /// Connection timed out
    pub const TIMEDOUT         : Error = unsafe { Error::new_unchecked(110) };
    /// Connection refused
    pub const CONNREFUSED      : Error = unsafe { Error::new_unchecked(111) };
    /// No route to host
    pub const HOSTUNREACH      : Error = unsafe { Error::new_unchecked(113) };
    /// Operation already in progress
    pub const ALREADY          : Error = unsafe { Error::new_unchecked(114) };
    /// Operation now in progress
    pub const INPROGRESS       : Error = unsafe { Error::new_unchecked(115) };
    /// Stale NFS file handle
    pub const STALE            : Error = unsafe { Error::new_unchecked(116) };
    /// Quota exceeded
    pub const DQUOT            : Error = unsafe { Error::new_unchecked(122) };
    /// Operation Canceled
    pub const CANCELED         : Error = unsafe { Error::new_unchecked(125) };
    /// Owner died
    pub const OWNERDEAD        : Error = unsafe { Error::new_unchecked(130) };
    /// State not recoverable
    pub const NOTRECOVERABLE   : Error = unsafe { Error::new_unchecked(131) };

}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            Error::GENERAL          => write!(f, "General error"),
            Error::NOENT            => write!(f, "No such file or directory"),
            Error::SRCH             => write!(f, "No such process"),
            Error::INTR             => write!(f, "Interrupted system call"),
            Error::IO               => write!(f, "I/O error"),
            Error::NXIO             => write!(f, "No such device or address"),
            Error::TOOBIG           => write!(f, "Argument list too long"),
            Error::NOEXEC           => write!(f, "Exec format error"),
            Error::BADF             => write!(f, "Bad file number"),
            Error::CHILD            => write!(f, "No child processes"),
            Error::AGAIN            => write!(f, "Try again"),
            Error::NOMEM            => write!(f, "Out of memory"),
            Error::ACCES            => write!(f, "Permission denied"),
            Error::FAULT            => write!(f, "Bad address"),
            Error::BUSY             => write!(f, "Device or resource busy"),
            Error::EXIST            => write!(f, "File exists"),
            Error::XDEV             => write!(f, "Cross-device link"),
            Error::NODEV            => write!(f, "No such device"),
            Error::NOTDIR           => write!(f, "Not a directory"),
            Error::ISDIR            => write!(f, "Is a directory"),
            Error::INVAL            => write!(f, "Invalid argument"),
            Error::NFILE            => write!(f, "File table overflow"),
            Error::MFILE            => write!(f, "Too many open files"),
            Error::NOTTY            => write!(f, "Not a typewriter"),
            Error::TXTBSY           => write!(f, "Text file busy"),
            Error::FBIG             => write!(f, "File too large"),
            Error::NOSPC            => write!(f, "No space left on device"),
            Error::SPIPE            => write!(f, "Illegal seek"),
            Error::ROFS             => write!(f, "Read-only file system"),
            Error::MLINK            => write!(f, "Too many links"),
            Error::PIPE             => write!(f, "Broken pipe"),
            Error::DOM              => write!(f, "Math argument out of domain of func"),
            Error::RANGE            => write!(f, "Math result not representable"),
            Error::DEADLK           => write!(f, "Resource deadlock would occur"),
            Error::NAMETOOLONG      => write!(f, "File name too long"),
            Error::NOLCK            => write!(f, "No record locks available"),
            Error::NOSYS            => write!(f, "Function not implemented"),
            Error::NOTEMPTY         => write!(f, "Directory not empty"),
            Error::LOOP             => write!(f, "Too many symbolic links encountered"),
            Error::NOMSG            => write!(f, "No message of desired type"),
            Error::IDRM             => write!(f, "Identifier removed"),
            Error::NOSTR            => write!(f, "Device not a stream"),
            Error::NODATA           => write!(f, "No data available"),
            Error::TIME             => write!(f, "Timer expired"),
            Error::NOSR             => write!(f, "Out of streams resources"),
            Error::NOLINK           => write!(f, "Link has been severed"),
            Error::PROTO            => write!(f, "Protocol error"),
            Error::MULTIHOP         => write!(f, "Multihop attempted"),
            Error::BADMSG           => write!(f, "Not a data message"),
            Error::OVERFLOW         => write!(f, "Value too large for defined data type"),
            Error::ILSEQ            => write!(f, "Illegal byte sequence"),
            Error::NOTSOCK          => write!(f, "Socket operation on non-socket"),
            Error::DESTADDRREQ      => write!(f, "Destination address required"),
            Error::MSGSIZE          => write!(f, "Message too long"),
            Error::PROTOTYPE        => write!(f, "Protocol wrong type for socket"),
            Error::NOPROTOOPT       => write!(f, "Protocol not available"),
            Error::PROTONOSUPPORT   => write!(f, "Protocol not supported"),
            Error::OPNOTSUPP        => write!(f, "Operation not supported on transport endpoint"),
            Error::AFNOSUPPORT      => write!(f, "Address family not supported by protocol"),
            Error::ADDRINUSE        => write!(f, "Address already in use"),
            Error::ADDRNOTAVAIL     => write!(f, "Cannot assign requested address"),
            Error::NETDOWN          => write!(f, "Network is down"),
            Error::NETUNREACH       => write!(f, "Network is unreachable"),
            Error::NETRESET         => write!(f, "Network dropped connection because of reset"),
            Error::CONNABORTED      => write!(f, "Software caused connection abort"),
            Error::CONNRESET        => write!(f, "Connection reset by peer"),
            Error::NOBUFS           => write!(f, "No buffer space available"),
            Error::ISCONN           => write!(f, "Transport endpoint is already connected"),
            Error::NOTCONN          => write!(f, "Transport endpoint is not connected"),
            Error::TIMEDOUT         => write!(f, "Connection timed out"),
            Error::CONNREFUSED      => write!(f, "Connection refused"),
            Error::HOSTUNREACH      => write!(f, "No route to host"),
            Error::ALREADY          => write!(f, "Operation already in progress"),
            Error::INPROGRESS       => write!(f, "Operation now in progress"),
            Error::STALE            => write!(f, "Stale NFS file handle"),
            Error::DQUOT            => write!(f, "Quota exceeded"),
            Error::CANCELED         => write!(f, "Operation Canceled"),
            Error::OWNERDEAD        => write!(f, "Owner died"),
            Error::NOTRECOVERABLE   => write!(f, "State not recoverable"),
            _                       => write!(f, "Error {}", self.get()),
        }
    }
}

pub type Result<T> = result::Result<T, Error>;

/// abort implementation
pub fn abort(err: Error) -> ! {
    extern "C" {
        pub fn __box_abort(err: i32) -> !;
    }

    let err = -err.get_i32();
    unsafe {
        __box_abort(err)
    }
}

/// panic handler which redirects to abort, passes Error types
/// through as error codes
#[panic_handler]
fn panic_handler(_info: &panic::PanicInfo) -> ! {
    extern "C" {
        pub fn __box_abort(err: i32) -> !;
    }

    // don't use anything from the PanicInfo, unfortunately
    // this would drag in a bunch of debug strings
    abort(Error::GENERAL)
}

pub fn write(fd: i32, buffer: &[u8]) -> Result<usize> {
    extern "C" {
        fn __box_write(fd: i32, buffer: *const u8, size: usize) -> isize;
    }

    let res = unsafe {
        __box_write(fd, buffer.as_ptr(), buffer.len())
    };

    usize::try_from(res)
        .map_err(|_| Error::new(-res as u32).unwrap())
}

/// stdout implementation
pub struct Stdout;

impl fmt::Write for Stdout {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        write(1, s.as_bytes())
            .map(|_| ())
            .map_err(|_| fmt::Error)
    }
}

pub fn stdout() -> Stdout {
    Stdout
}

#[macro_export]
macro_rules! print {
    ($($arg:tt)*) => ({
        use ::core::fmt::Write;

        struct Out;
        impl ::core::fmt::Write for Out {
            fn write_str(&mut self, s: &str) -> ::core::fmt::Result {
                extern "C" {
                    fn __box_write(
                        fd: i32,
                        buffer: *const u8,
                        size: usize
                    ) -> isize;
                }

                let b = s.as_bytes();
                let res = unsafe {
                    __box_write(1, b.as_ptr(), b.len())
                };

                if res < 0 {
                    Err(::core::fmt::Error)?
                }

                Ok(())
            }
        }

        ::core::write!(Out, $($arg)*).unwrap();
    });
}

#[macro_export]
macro_rules! println {
    () => ({
        $crate::print!("\n");
    });
    ($($arg:tt)*) => ({
        $crate::print!($($arg)*);
        $crate::print!("\n");
    });
}

/// stderr implementation
pub struct Stderr;

impl fmt::Write for Stderr {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        write(2, s.as_bytes())
            .map(|_| ())
            .map_err(|_| fmt::Error)
    }
}

pub fn stderr() -> Stderr {
    Stderr
}

#[macro_export]
macro_rules! eprint {
    ($($arg:tt)*) => ({
        use ::core::fmt::Write;

        struct Out;
        impl ::core::fmt::Write for Out {
            fn write_str(&mut self, s: &str) -> ::core::fmt::Result {
                extern "C" {
                    fn __box_write(
                        fd: i32,
                        buffer: *const u8,
                        size: usize
                    ) -> isize;
                }

                let b = s.as_bytes();
                let res = unsafe {
                    __box_write(1, b.as_ptr(), b.len())
                };

                if res < 0 {
                    Err(::core::fmt::Error)?
                }

                Ok(())
            }
        }

        ::core::write!(Out, $($arg)*).unwrap();
    });
}

#[macro_export]
macro_rules! eprintln {
    () => ({
        $crate::eprint!("\n");
    });
    ($($arg:tt)*) => ({
        $crate::eprint!($($arg)*);
        $crate::eprint!("\n");
    });
}

