###### BENTO-BOX AUTOGENERATED ######

TARGET           ?= box1.elf
CROSS_COMPILE    ?= arm-none-eabi-
DEBUG            ?= 0
LTO              ?= 1
CC               = $(CROSS_COMPILE)gcc
OBJCOPY          = $(CROSS_COMPILE)objcopy
OBJDUMP          = $(CROSS_COMPILE)objdump
AR               = $(CROSS_COMPILE)ar
SIZE             = $(CROSS_COMPILE)size
GDB              = $(CROSS_COMPILE)gdb
GDBADDR          ?= localhost
GDBPORT          ?= 3333
TTY              ?= $(firstword $(wildcard /dev/ttyACM* /dev/ttyUSB*))
BAUD             ?= 115200
CARGO			 = cargo
CARGO_TARGET	 = thumbv7em-none-eabi

SRC := .

INC := .

LIB := m
LIB += c
LIB += gcc
LIB += nosys

LDSCRIPT := $(firstword $(wildcard $(patsubst %,%/*.ld,$(SRC))))

ARCHIVES := $(wildcard $(patsubst %,%/lib*.a,$(SRC)))

CARGOTOMLS := $(wildcard $(patsubst %,%/Cargo.toml,$(SRC)))
#CARGOARCHIVES := $(patsubst %/Cargo.toml,$(foreach lib,$\
#	$(shell $(CARGO) metadata --format-version=1 --no-deps$\
#		| jq -r '.packages|.[].name'),$\
#	%/target/$(CARGO_TARGET)/$\
#		$(if $(filter-out 0,$(DEBUG)),debug,release)/lib$(lib).a),$\
#	$(CARGOTOMLS))
#ARCHIVES += $(CARGOARCHIVES)
CARGOTOMLS2ARCHIVES = $(patsubst %/Cargo.toml,$(foreach lib,$\
	$(shell $(CARGO) metadata --format-version=1 --no-deps$\
		| jq -r '.packages|.[].name'),$\
	%/target/$(CARGO_TARGET)/$\
		$(if $(filter-out 0,$(DEBUG)),debug,release)/$\
		lib$(lib).a),$\
	$(1))
ARCHIVES += $(call CARGOTOMLS2ARCHIVES,$(CARGOTOMLS))
$(info ARCHIVES $(ARCHIVES))



LIB += $(patsubst lib%.a,%,$(notdir $(ARCHIVES)))
override LDFLAGS += $(patsubst %,-L%,$(dir $(ARCHIVES)))

#LIB += $(patsubst lib%.a,%,$(notdir $(wildcard $(patsubst %,%/lib*.a,$(SRC)))))
#override LDFLAGS += $(patsubst %,-L%,
#	$(dir $(wildcard $(patsubst %,%/lib*.a,$(SRC))))
#
#LIB += $(patsubst lib%.a,%,$(notdir $(wildcard $(patsubst %,%/lib*.a,$(SRC)))))
#override LDFLAGS += $(patsubst %,-L%,
#	$(dir $(wildcard $(patsubst %,%/lib*.a,$(SRC))))

$(info CARGOTOMLS $(CARGOTOMLS))
$(info CARGOARCHIVES $(CARGOARCHIVES))
$(info LIB $(LIB))

OBJ := $(patsubst %.c,%.o,$(wildcard $(patsubst %,%/*.c,$(SRC))))
OBJ += $(patsubst %.s,%.o,$(wildcard $(patsubst %,%/*.s,$(SRC))))
OBJ += $(patsubst %.S,%.o,$(wildcard $(patsubst %,%/*.S,$(SRC))))
DEP := $(patsubst %.o,%.d,$(OBJ))

ifneq ($(DEBUG),0)
override CFLAGS += -DDEBUG
override CFLAGS += -g
override CFLAGS += -O0
else
override CFLAGS += -DNDEBUG
override CFLAGS += -Os
ifneq ($(LTO),0)
override CFLAGS += -flto
endif
endif
override CFLAGS += -mthumb
override CFLAGS += -mcpu=cortex-m4
override CFLAGS += -mfpu=fpv4-sp-d16
override CFLAGS += -mfloat-abi=softfp
override CFLAGS += -std=c99
override CFLAGS += -Wall -Wno-format
override CFLAGS += -fno-common
override CFLAGS += -ffunction-sections
override CFLAGS += -fdata-sections
override CFLAGS += -ffreestanding
override CFLAGS += -fno-builtin
override CFLAGS += $(patsubst %,-I%,$(INC))

override ASFLAGS += $(CFLAGS)

override LDFLAGS += $(CFLAGS)
override LDFLAGS += -T$(LDSCRIPT)
override LDFLAGS += -Wl,--start-group $(patsubst %,-l%,$(LIB)) -Wl,--end-group
override LDFLAGS += -static
override LDFLAGS += --specs=nano.specs
override LDFLAGS += --specs=nosys.specs
override LDFLAGS += -Wl,--gc-sections
override LDFLAGS += -Wl,-static
override LDFLAGS += -Wl,-z,muldefs

override CARGOFLAGS += --target=$(CARGO_TARGET)
ifeq ($(DEBUG),0)
override CARGOFLAGS += --release
endif

### __box_abort glue ###
override LDFLAGS += -Wl,--wrap,abort

### __box_write glue ###
override LDFLAGS += -Wl,--wrap,printf
override LDFLAGS += -Wl,--wrap,vprintf
override LDFLAGS += -Wl,--wrap,fprintf
override LDFLAGS += -Wl,--wrap,vfprintf
override LDFLAGS += -Wl,--wrap,fflush

# target rule
$(TARGET): $(OBJ) $(ARCHIVES) $(BOXES) $(LDSCRIPT)
	$(CC) $(OBJ) $(BOXES) $(LDFLAGS) -o $@

define CARGORULE
.PHONY: $(toml)
$(call CARGOTOMLS2ARCHIVES,$(toml)): $(toml)
	$(CARGO) build --manifest-path=$$< $(CARGOFLAGS)
endef
$(foreach toml,$(CARGOTOMLS),$(eval $(CARGORULE)))

#define CARGORULE
#.PHONY: $(lib)
#$(lib): $(abspath $(dir $(lib))../../../Cargo.toml)
#	$(CARGO) build --manifest-path=$$< $(CARGOFLAGS)
#endef
#$(foreach lib,$(CARGOARCHIVES),$(eval $(CARGORULE)))

# a .box is a .elf containing a single section for each loadable memory region
%.box: %.elf %.box.flash
	$(strip $(OBJCOPY) $< $@ \
	    -I binary \
	    -O elf32-littlearm \
	    -B arm \
	    --strip-all \
	    --remove-section=* \
	    --add-section .box.box1.flash=$(word 2,$^) \
	    --change-section-address .box.box1.flash=0x000fe000 \
	    --set-section-flags .box.box1.flash=contents,alloc,load,readonly,data)

%.box.flash: %.elf
	$(strip $(OBJCOPY) $< $@ \
	    --only-section .text \
	    --only-section .data \
	    --only-section .jumptable \
	    -O binary)

### rules ###

# default rule
.PHONY: all build
all build: $(TARGET)

# computing size size is a bit complicated as each .elf includes its boxes, we
# want independent sizes.
.PHONY: size
size: $(TARGET) $(BOXES)
	$(SIZE) $<

.PHONY: debug
debug: $(TARGET)
	echo '$$qRcmd,68616c74#fc' | nc -N $(GDBADDR) $(GDBPORT) && echo # halt
	$(strip $(GDB) $< \
	    -ex "target remote $(GDBADDR):$(GDBPORT)")
	echo '$$qRcmd,676f#2c' | nc -N $(GDBADDR) $(GDBPORT) && echo # go

.PHONY: flash
flash: $(TARGET)
	echo '$$qRcmd,68616c74#fc' | nc -N $(GDBADDR) $(GDBPORT) && echo # halt
	$(strip $(GDB) $< \
	    -ex "target remote $(GDBADDR):$(GDBPORT)" \
	    -ex "load" \
	    -ex "monitor reset" \
	    -batch)

.PHONY: reset
reset:
	echo '$$qRcmd,7265736574#37' | nc -N $(GDBADDR) $(GDBPORT) && echo # reset
	echo '$$qRcmd,676f#2c' | nc -N $(GDBADDR) $(GDBPORT) && echo # go

.PHONY: cat
cat:
	stty -F $(TTY) sane nl $(BAUD)
	cat $(TTY)

.PHONY: tags
tags:
	$(strip ctags \
	    $(wildcard $(patsubst %,%/*.c,$(SRC))) \
	    $(wildcard $(patsubst %,%/*.s,$(SRC))) \
	    $(wildcard $(patsubst %,%/*.S,$(SRC))))

# header dependencies
-include $(DEP)

%.bin: %.elf
	$(OBJCOPY) -O binary $< $@

%.o: %.c
	$(CC) -c -MMD -MP $(CFLAGS) $< -o $@

%.s: %.c
	$(CC) -S -MMD -MP $(CFLAGS) $< -o $@

%.o: %.s
	$(CC) -c -MMD -MP $(ASFLAGS) $< -o $@

%.o: %.S
	$(CC) -c -MMD -MP $(ASFLAGS) $< -o $@

.PHONY: clean
clean:
	rm -f $(TARGET) $(BOXES)
	rm -f $(OBJ)
	rm -f $(DEP)
	$(patsubst %,$(CARGO) clean --manifest-path=%,$(CARGOTOMLS))

