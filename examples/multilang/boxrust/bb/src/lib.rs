////// AUTOGENERATED //////
#![no_std]
use core::fmt;
use core::num;
use core::panic;
use core::result;

extern crate bento_macros;
pub use bento_macros::export;

pub mod import {
    #[allow(unused_imports)]
    use core::{convert::TryFrom, ptr, slice};
    #[allow(unused_imports)]
    use crate::{Result, Error};
}

pub mod export {
    #[allow(unused_imports)]
    use bento_macros::export_export;

    #[export_export(type=fn(a0: i32, a1: i32) -> __box_exports::Result<u32>)]
    pub fn boxrust_add2(a0: i32, a1: i32) -> i32 {
        #[allow(unused_imports)]
        use core::{convert::TryFrom, ptr, slice};
        #[allow(unused_imports)]
        use __box_exports::{Result, Error};
        let r0 = __box_export_boxrust_add2(a0, a1);
        let r0 = match r0 {
            Ok(x) => i32::try_from(x).unwrap(),
            Err(err) => -err.get_i32(),
        };
        r0
    }

    #[export_export(type=fn(buffer: &mut [u32], a: u32, b: u32) -> __box_exports::Result<()>)]
    pub fn boxrust_fib(buffer: *mut u32, size: usize, a: u32, b: u32) -> i32 {
        #[allow(unused_imports)]
        use core::{convert::TryFrom, ptr, slice};
        #[allow(unused_imports)]
        use __box_exports::{Result, Error};
        let buffer = unsafe { slice::from_raw_parts_mut(buffer, size) };
        let r0 = __box_export_boxrust_fib(buffer, a, b);
        let r0 = match r0 {
            Ok(()) => 0,
            Err(err) => -err.get_i32(),
        };
        r0
    }

    #[export_export(type=fn(size: usize) -> Option<&'static mut u8>)]
    pub fn boxrust_fib_alloc(size: usize) -> *mut u8 {
        #[allow(unused_imports)]
        use core::{convert::TryFrom, ptr, slice};
        #[allow(unused_imports)]
        use __box_exports::{Result, Error};
        let r0 = __box_export_boxrust_fib_alloc(size);
        let r0 = match r0 {
            Some(r0) => {
                let r0 = r0 as *mut u8;
                r0
            },
            None => ptr::null_mut(),
        };
        r0
    }

    #[export_export(type=fn(next: &mut u32, a: u32, b: u32) -> __box_exports::Result<()>)]
    pub fn boxrust_fib_next(next: *mut u32, a: u32, b: u32) -> i32 {
        #[allow(unused_imports)]
        use core::{convert::TryFrom, ptr, slice};
        #[allow(unused_imports)]
        use __box_exports::{Result, Error};
        let next = unsafe { &mut *next };
        let r0 = __box_export_boxrust_fib_next(next, a, b);
        let r0 = match r0 {
            Ok(()) => 0,
            Err(err) => -err.get_i32(),
        };
        r0
    }

    #[export_export(type=fn() -> __box_exports::Result<()>)]
    pub fn boxrust_hello() -> i32 {
        #[allow(unused_imports)]
        use core::{convert::TryFrom, ptr, slice};
        #[allow(unused_imports)]
        use __box_exports::{Result, Error};
        let r0 = __box_export_boxrust_hello();
        let r0 = match r0 {
            Ok(()) => 0,
            Err(err) => -err.get_i32(),
        };
        r0
    }

    #[export_export(type=fn(buffer: &mut [u32]) -> __box_exports::Result<()>)]
    pub fn boxrust_qsort(buffer: *mut u32, size: usize) -> i32 {
        #[allow(unused_imports)]
        use core::{convert::TryFrom, ptr, slice};
        #[allow(unused_imports)]
        use __box_exports::{Result, Error};
        let buffer = unsafe { slice::from_raw_parts_mut(buffer, size) };
        let r0 = __box_export_boxrust_qsort(buffer);
        let r0 = match r0 {
            Ok(()) => 0,
            Err(err) => -err.get_i32(),
        };
        r0
    }

    #[export_export(type=fn(size: usize) -> Option<&'static mut u8>)]
    pub fn boxrust_qsort_alloc(size: usize) -> *mut u8 {
        #[allow(unused_imports)]
        use core::{convert::TryFrom, ptr, slice};
        #[allow(unused_imports)]
        use __box_exports::{Result, Error};
        let r0 = __box_export_boxrust_qsort_alloc(size);
        let r0 = match r0 {
            Some(r0) => {
                let r0 = r0 as *mut u8;
                r0
            },
            None => ptr::null_mut(),
        };
        r0
    }

    #[export_export(type=fn(buffer: &mut [u32], pivot: u32) -> __box_exports::Result<usize>)]
    pub fn boxrust_qsort_partition(buffer: *mut u32, size: usize, pivot: u32) -> isize {
        #[allow(unused_imports)]
        use core::{convert::TryFrom, ptr, slice};
        #[allow(unused_imports)]
        use __box_exports::{Result, Error};
        let buffer = unsafe { slice::from_raw_parts_mut(buffer, size) };
        let r0 = __box_export_boxrust_qsort_partition(buffer, pivot);
        let r0 = match r0 {
            Ok(x) => isize::try_from(x).unwrap(),
            Err(err) => isize::try_from(-err.get_i32()).unwrap(),
        };
        r0
    }
}

/// Error type, internally wraps a u31
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Error(num::NonZeroU32);

impl Error {
    pub const unsafe fn new_unchecked(code: u32) -> Self {
        Self(num::NonZeroU32::new_unchecked(code))
    }

    pub fn new(code: u32) -> Option<Self> {
        if code < 2u32.pow(31) {
            Some(Self(num::NonZeroU32::new(code)?))
        } else {
            None
        }
    }

    pub const fn get(self) -> u32 {
        self.0.get()
    }

    /// Error codes are 31-bit values, so we can convert to
    /// an i32 safely
    pub const fn get_i32(self) -> i32 {
        self.0.get() as i32
    }
}

impl Default for Error {
    fn default() -> Self {
        Self::General
    }
}

impl Error {
    /// General error
    #[allow(non_upper_case_globals)]
    pub const General          : Error
        = unsafe { Error::new_unchecked(1) };
    /// No such file or directory
    #[allow(non_upper_case_globals)]
    pub const NoEnt            : Error
        = unsafe { Error::new_unchecked(2) };
    /// No such process
    #[allow(non_upper_case_globals)]
    pub const Srch             : Error
        = unsafe { Error::new_unchecked(3) };
    /// Interrupted system call
    #[allow(non_upper_case_globals)]
    pub const Intr             : Error
        = unsafe { Error::new_unchecked(4) };
    /// I/O error
    #[allow(non_upper_case_globals)]
    pub const Io               : Error
        = unsafe { Error::new_unchecked(5) };
    /// No such device or address
    #[allow(non_upper_case_globals)]
    pub const NXIo             : Error
        = unsafe { Error::new_unchecked(6) };
    /// Argument list too long
    #[allow(non_upper_case_globals)]
    pub const TooBig           : Error
        = unsafe { Error::new_unchecked(7) };
    /// Exec format error
    #[allow(non_upper_case_globals)]
    pub const NoExec           : Error
        = unsafe { Error::new_unchecked(8) };
    /// Bad file number
    #[allow(non_upper_case_globals)]
    pub const BadF             : Error
        = unsafe { Error::new_unchecked(9) };
    /// No child processes
    #[allow(non_upper_case_globals)]
    pub const Child            : Error
        = unsafe { Error::new_unchecked(10) };
    /// Try again
    #[allow(non_upper_case_globals)]
    pub const Again            : Error
        = unsafe { Error::new_unchecked(11) };
    /// Out of memory
    #[allow(non_upper_case_globals)]
    pub const NoMem            : Error
        = unsafe { Error::new_unchecked(12) };
    /// Permission denied
    #[allow(non_upper_case_globals)]
    pub const Acces            : Error
        = unsafe { Error::new_unchecked(13) };
    /// Bad address
    #[allow(non_upper_case_globals)]
    pub const Fault            : Error
        = unsafe { Error::new_unchecked(14) };
    /// Device or resource busy
    #[allow(non_upper_case_globals)]
    pub const Busy             : Error
        = unsafe { Error::new_unchecked(16) };
    /// File exists
    #[allow(non_upper_case_globals)]
    pub const Exist            : Error
        = unsafe { Error::new_unchecked(17) };
    /// Cross-device link
    #[allow(non_upper_case_globals)]
    pub const XDev             : Error
        = unsafe { Error::new_unchecked(18) };
    /// No such device
    #[allow(non_upper_case_globals)]
    pub const NoDev            : Error
        = unsafe { Error::new_unchecked(19) };
    /// Not a directory
    #[allow(non_upper_case_globals)]
    pub const NotDir           : Error
        = unsafe { Error::new_unchecked(20) };
    /// Is a directory
    #[allow(non_upper_case_globals)]
    pub const IsDir            : Error
        = unsafe { Error::new_unchecked(21) };
    /// Invalid argument
    #[allow(non_upper_case_globals)]
    pub const Inval            : Error
        = unsafe { Error::new_unchecked(22) };
    /// File table overflow
    #[allow(non_upper_case_globals)]
    pub const NFile            : Error
        = unsafe { Error::new_unchecked(23) };
    /// Too many open files
    #[allow(non_upper_case_globals)]
    pub const MFile            : Error
        = unsafe { Error::new_unchecked(24) };
    /// Not a typewriter
    #[allow(non_upper_case_globals)]
    pub const NoTty            : Error
        = unsafe { Error::new_unchecked(25) };
    /// Text file busy
    #[allow(non_upper_case_globals)]
    pub const TxtBsy           : Error
        = unsafe { Error::new_unchecked(26) };
    /// File too large
    #[allow(non_upper_case_globals)]
    pub const FBig             : Error
        = unsafe { Error::new_unchecked(27) };
    /// No space left on device
    #[allow(non_upper_case_globals)]
    pub const NoSpc            : Error
        = unsafe { Error::new_unchecked(28) };
    /// Illegal seek
    #[allow(non_upper_case_globals)]
    pub const SPipe            : Error
        = unsafe { Error::new_unchecked(29) };
    /// Read-only file system
    #[allow(non_upper_case_globals)]
    pub const RoFs             : Error
        = unsafe { Error::new_unchecked(30) };
    /// Too many links
    #[allow(non_upper_case_globals)]
    pub const MLink            : Error
        = unsafe { Error::new_unchecked(31) };
    /// Broken pipe
    #[allow(non_upper_case_globals)]
    pub const Pipe             : Error
        = unsafe { Error::new_unchecked(32) };
    /// Math argument out of domain of func
    #[allow(non_upper_case_globals)]
    pub const Dom              : Error
        = unsafe { Error::new_unchecked(33) };
    /// Math result not representable
    #[allow(non_upper_case_globals)]
    pub const Range            : Error
        = unsafe { Error::new_unchecked(34) };
    /// Resource deadlock would occur
    #[allow(non_upper_case_globals)]
    pub const DeadLk           : Error
        = unsafe { Error::new_unchecked(35) };
    /// File name too long
    #[allow(non_upper_case_globals)]
    pub const NameTooLong      : Error
        = unsafe { Error::new_unchecked(36) };
    /// No record locks available
    #[allow(non_upper_case_globals)]
    pub const NoLck            : Error
        = unsafe { Error::new_unchecked(37) };
    /// Function not implemented
    #[allow(non_upper_case_globals)]
    pub const NoSys            : Error
        = unsafe { Error::new_unchecked(38) };
    /// Directory not empty
    #[allow(non_upper_case_globals)]
    pub const NotEmpty         : Error
        = unsafe { Error::new_unchecked(39) };
    /// Too many symbolic links encountered
    #[allow(non_upper_case_globals)]
    pub const Loop             : Error
        = unsafe { Error::new_unchecked(40) };
    /// No message of desired type
    #[allow(non_upper_case_globals)]
    pub const NoMsg            : Error
        = unsafe { Error::new_unchecked(42) };
    /// Identifier removed
    #[allow(non_upper_case_globals)]
    pub const IdRm             : Error
        = unsafe { Error::new_unchecked(43) };
    /// Device not a stream
    #[allow(non_upper_case_globals)]
    pub const NoStr            : Error
        = unsafe { Error::new_unchecked(60) };
    /// No data available
    #[allow(non_upper_case_globals)]
    pub const NoData           : Error
        = unsafe { Error::new_unchecked(61) };
    /// Timer expired
    #[allow(non_upper_case_globals)]
    pub const Time             : Error
        = unsafe { Error::new_unchecked(62) };
    /// Out of streams resources
    #[allow(non_upper_case_globals)]
    pub const NoSr             : Error
        = unsafe { Error::new_unchecked(63) };
    /// Link has been severed
    #[allow(non_upper_case_globals)]
    pub const NoLink           : Error
        = unsafe { Error::new_unchecked(67) };
    /// Protocol error
    #[allow(non_upper_case_globals)]
    pub const Proto            : Error
        = unsafe { Error::new_unchecked(71) };
    /// Multihop attempted
    #[allow(non_upper_case_globals)]
    pub const Multihop         : Error
        = unsafe { Error::new_unchecked(72) };
    /// Not a data message
    #[allow(non_upper_case_globals)]
    pub const BadMsg           : Error
        = unsafe { Error::new_unchecked(74) };
    /// Value too large for defined data type
    #[allow(non_upper_case_globals)]
    pub const Overflow         : Error
        = unsafe { Error::new_unchecked(75) };
    /// Illegal byte sequence
    #[allow(non_upper_case_globals)]
    pub const IlSeq            : Error
        = unsafe { Error::new_unchecked(84) };
    /// Socket operation on non-socket
    #[allow(non_upper_case_globals)]
    pub const NotSock          : Error
        = unsafe { Error::new_unchecked(88) };
    /// Destination address required
    #[allow(non_upper_case_globals)]
    pub const DestAddrReq      : Error
        = unsafe { Error::new_unchecked(89) };
    /// Message too long
    #[allow(non_upper_case_globals)]
    pub const MsgSize          : Error
        = unsafe { Error::new_unchecked(90) };
    /// Protocol wrong type for socket
    #[allow(non_upper_case_globals)]
    pub const Prototype        : Error
        = unsafe { Error::new_unchecked(91) };
    /// Protocol not available
    #[allow(non_upper_case_globals)]
    pub const NoProtoOpt       : Error
        = unsafe { Error::new_unchecked(92) };
    /// Protocol not supported
    #[allow(non_upper_case_globals)]
    pub const ProtoNoSupport   : Error
        = unsafe { Error::new_unchecked(93) };
    /// Operation not supported on transport endpoint
    #[allow(non_upper_case_globals)]
    pub const OpNotSupp        : Error
        = unsafe { Error::new_unchecked(95) };
    /// Address family not supported by protocol
    #[allow(non_upper_case_globals)]
    pub const AfNoSupport      : Error
        = unsafe { Error::new_unchecked(97) };
    /// Address already in use
    #[allow(non_upper_case_globals)]
    pub const AddrInUse        : Error
        = unsafe { Error::new_unchecked(98) };
    /// Cannot assign requested address
    #[allow(non_upper_case_globals)]
    pub const AddrNotAvail     : Error
        = unsafe { Error::new_unchecked(99) };
    /// Network is down
    #[allow(non_upper_case_globals)]
    pub const NetDown          : Error
        = unsafe { Error::new_unchecked(100) };
    /// Network is unreachable
    #[allow(non_upper_case_globals)]
    pub const NetUnreach       : Error
        = unsafe { Error::new_unchecked(101) };
    /// Network dropped connection because of reset
    #[allow(non_upper_case_globals)]
    pub const NetReset         : Error
        = unsafe { Error::new_unchecked(102) };
    /// Software caused connection abort
    #[allow(non_upper_case_globals)]
    pub const ConnAborted      : Error
        = unsafe { Error::new_unchecked(103) };
    /// Connection reset by peer
    #[allow(non_upper_case_globals)]
    pub const ConnReset        : Error
        = unsafe { Error::new_unchecked(104) };
    /// No buffer space available
    #[allow(non_upper_case_globals)]
    pub const NoBufs           : Error
        = unsafe { Error::new_unchecked(105) };
    /// Transport endpoint is already connected
    #[allow(non_upper_case_globals)]
    pub const IsConn           : Error
        = unsafe { Error::new_unchecked(106) };
    /// Transport endpoint is not connected
    #[allow(non_upper_case_globals)]
    pub const NotConn          : Error
        = unsafe { Error::new_unchecked(107) };
    /// Connection timed out
    #[allow(non_upper_case_globals)]
    pub const TimedOut         : Error
        = unsafe { Error::new_unchecked(110) };
    /// Connection refused
    #[allow(non_upper_case_globals)]
    pub const ConnRefused      : Error
        = unsafe { Error::new_unchecked(111) };
    /// No route to host
    #[allow(non_upper_case_globals)]
    pub const HostUnreach      : Error
        = unsafe { Error::new_unchecked(113) };
    /// Operation already in progress
    #[allow(non_upper_case_globals)]
    pub const Already          : Error
        = unsafe { Error::new_unchecked(114) };
    /// Operation now in progress
    #[allow(non_upper_case_globals)]
    pub const InProgress       : Error
        = unsafe { Error::new_unchecked(115) };
    /// Stale NFS file handle
    #[allow(non_upper_case_globals)]
    pub const Stale            : Error
        = unsafe { Error::new_unchecked(116) };
    /// Quota exceeded
    #[allow(non_upper_case_globals)]
    pub const DQuot            : Error
        = unsafe { Error::new_unchecked(122) };
    /// Operation Canceled
    #[allow(non_upper_case_globals)]
    pub const Canceled         : Error
        = unsafe { Error::new_unchecked(125) };
    /// Owner died
    #[allow(non_upper_case_globals)]
    pub const OwnerDead        : Error
        = unsafe { Error::new_unchecked(130) };
    /// State not recoverable
    #[allow(non_upper_case_globals)]
    pub const NotRecoverable   : Error
        = unsafe { Error::new_unchecked(131) };

}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            Error::General          => write!(f, "General error"),
            Error::NoEnt            => write!(f, "No such file or directory"),
            Error::Srch             => write!(f, "No such process"),
            Error::Intr             => write!(f, "Interrupted system call"),
            Error::Io               => write!(f, "I/O error"),
            Error::NXIo             => write!(f, "No such device or address"),
            Error::TooBig           => write!(f, "Argument list too long"),
            Error::NoExec           => write!(f, "Exec format error"),
            Error::BadF             => write!(f, "Bad file number"),
            Error::Child            => write!(f, "No child processes"),
            Error::Again            => write!(f, "Try again"),
            Error::NoMem            => write!(f, "Out of memory"),
            Error::Acces            => write!(f, "Permission denied"),
            Error::Fault            => write!(f, "Bad address"),
            Error::Busy             => write!(f, "Device or resource busy"),
            Error::Exist            => write!(f, "File exists"),
            Error::XDev             => write!(f, "Cross-device link"),
            Error::NoDev            => write!(f, "No such device"),
            Error::NotDir           => write!(f, "Not a directory"),
            Error::IsDir            => write!(f, "Is a directory"),
            Error::Inval            => write!(f, "Invalid argument"),
            Error::NFile            => write!(f, "File table overflow"),
            Error::MFile            => write!(f, "Too many open files"),
            Error::NoTty            => write!(f, "Not a typewriter"),
            Error::TxtBsy           => write!(f, "Text file busy"),
            Error::FBig             => write!(f, "File too large"),
            Error::NoSpc            => write!(f, "No space left on device"),
            Error::SPipe            => write!(f, "Illegal seek"),
            Error::RoFs             => write!(f, "Read-only file system"),
            Error::MLink            => write!(f, "Too many links"),
            Error::Pipe             => write!(f, "Broken pipe"),
            Error::Dom              => write!(f, "Math argument out of domain of func"),
            Error::Range            => write!(f, "Math result not representable"),
            Error::DeadLk           => write!(f, "Resource deadlock would occur"),
            Error::NameTooLong      => write!(f, "File name too long"),
            Error::NoLck            => write!(f, "No record locks available"),
            Error::NoSys            => write!(f, "Function not implemented"),
            Error::NotEmpty         => write!(f, "Directory not empty"),
            Error::Loop             => write!(f, "Too many symbolic links encountered"),
            Error::NoMsg            => write!(f, "No message of desired type"),
            Error::IdRm             => write!(f, "Identifier removed"),
            Error::NoStr            => write!(f, "Device not a stream"),
            Error::NoData           => write!(f, "No data available"),
            Error::Time             => write!(f, "Timer expired"),
            Error::NoSr             => write!(f, "Out of streams resources"),
            Error::NoLink           => write!(f, "Link has been severed"),
            Error::Proto            => write!(f, "Protocol error"),
            Error::Multihop         => write!(f, "Multihop attempted"),
            Error::BadMsg           => write!(f, "Not a data message"),
            Error::Overflow         => write!(f, "Value too large for defined data type"),
            Error::IlSeq            => write!(f, "Illegal byte sequence"),
            Error::NotSock          => write!(f, "Socket operation on non-socket"),
            Error::DestAddrReq      => write!(f, "Destination address required"),
            Error::MsgSize          => write!(f, "Message too long"),
            Error::Prototype        => write!(f, "Protocol wrong type for socket"),
            Error::NoProtoOpt       => write!(f, "Protocol not available"),
            Error::ProtoNoSupport   => write!(f, "Protocol not supported"),
            Error::OpNotSupp        => write!(f, "Operation not supported on transport endpoint"),
            Error::AfNoSupport      => write!(f, "Address family not supported by protocol"),
            Error::AddrInUse        => write!(f, "Address already in use"),
            Error::AddrNotAvail     => write!(f, "Cannot assign requested address"),
            Error::NetDown          => write!(f, "Network is down"),
            Error::NetUnreach       => write!(f, "Network is unreachable"),
            Error::NetReset         => write!(f, "Network dropped connection because of reset"),
            Error::ConnAborted      => write!(f, "Software caused connection abort"),
            Error::ConnReset        => write!(f, "Connection reset by peer"),
            Error::NoBufs           => write!(f, "No buffer space available"),
            Error::IsConn           => write!(f, "Transport endpoint is already connected"),
            Error::NotConn          => write!(f, "Transport endpoint is not connected"),
            Error::TimedOut         => write!(f, "Connection timed out"),
            Error::ConnRefused      => write!(f, "Connection refused"),
            Error::HostUnreach      => write!(f, "No route to host"),
            Error::Already          => write!(f, "Operation already in progress"),
            Error::InProgress       => write!(f, "Operation now in progress"),
            Error::Stale            => write!(f, "Stale NFS file handle"),
            Error::DQuot            => write!(f, "Quota exceeded"),
            Error::Canceled         => write!(f, "Operation Canceled"),
            Error::OwnerDead        => write!(f, "Owner died"),
            Error::NotRecoverable   => write!(f, "State not recoverable"),
            _                       => write!(f, "Error {}", self.get()),
        }
    }
}

pub type Result<T> = result::Result<T, Error>;

/// abort implementation
pub fn abort(err: Error) -> ! {
    extern "C" {
        pub fn __box_abort(err: i32) -> !;
    }

    let err = -err.get_i32();
    unsafe {
        __box_abort(err)
    }
}

/// panic handler which redirects to abort, passes Error types
/// through as error codes
#[panic_handler]
fn panic_handler(_info: &panic::PanicInfo) -> ! {
    extern "C" {
        pub fn __box_abort(err: i32) -> !;
    }

    // don't use anything from the PanicInfo, unfortunately
    // this would drag in a bunch of debug strings
    abort(Error::General)
}

pub fn write(fd: i32, buffer: &[u8]) -> Result<usize> {
    extern "C" {
        fn __box_write(fd: i32, buffer: *const u8, size: usize) -> isize;
    }

    let res = unsafe { __box_write(fd, buffer.as_ptr(), buffer.len()) };
    if res < 0 {
        Err(Error::new(-res as u32).unwrap())?;
    }

    Ok(res as usize)
}

pub fn flush(fd: i32) -> Result<()> {
    extern "C" {
        fn __box_flush(fd: i32) -> i32;
    }

    let res = unsafe { __box_flush(fd) };
    if res < 0 {
        Err(Error::new(-res as u32).unwrap())?;
    }

    Ok(())
}

/// stdout implementation
pub struct Stdout;

pub fn stdout() -> Stdout {
    Stdout
}

impl Stdout {
    pub fn write(&mut self, buf: &[u8]) -> Result<usize> {
        write(1, buf)
    }

    pub fn flush(&mut self) -> Result<()> {
        flush(1)
    }
}

impl fmt::Write for Stdout {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        match self.write(s.as_bytes()) {
            Ok(_) => Ok(()),
            Err(_) => Err(fmt::Error),
        }
    }
}

#[macro_export]
macro_rules! print {
    ($($arg:tt)*) => ({
        use ::core::fmt::Write;
        ::core::write!(Stdout, $($arg)*).unwrap();
    });
}

#[macro_export]
macro_rules! println {
    () => ({
        $crate::print!("\n");
    });
    ($($arg:tt)*) => ({
        $crate::print!($($arg)*);
        $crate::print!("\n");
    });
}

/// stderr implementation
pub struct Stderr;

pub fn stderr() -> Stderr {
    Stderr
}

impl Stderr {
    pub fn write(&mut self, buf: &[u8]) -> Result<usize> {
        write(2, buf)
    }

    pub fn flush(&mut self) -> Result<()> {
        flush(2)
    }
}

impl fmt::Write for Stderr {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        match self.write(s.as_bytes()) {
            Ok(_) => Ok(()),
            Err(_) => Err(fmt::Error),
        }
    }
}

#[macro_export]
macro_rules! eprint {
    ($($arg:tt)*) => ({
        use ::core::fmt::Write;
        ::core::write!(Stderr, $($arg)*).unwrap();
    });
}

#[macro_export]
macro_rules! eprintln {
    () => ({
        $crate::eprint!("\n");
    });
    ($($arg:tt)*) => ({
        $crate::eprint!($($arg)*);
        $crate::eprint!("\n");
    });
}

