////// AUTOGENERATED //////
#include <m3_api_defs.h>
#include <m3_env.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <wasm3.h>

//// box imports ////

int alicebox_getpubkey(char *buffer, size_t size);

int alicebox_init(void);

int alicebox_main(void);

int alicebox_recv(const void *buffer, size_t size);

int bobbox_getpubkey(char *buffer, size_t size);

int bobbox_init(void);

int bobbox_main(void);

int bobbox_recv(const void *buffer, size_t size);

int tlsbox_drbg_seed(void);

int tlsbox_rsa_freekey(int32_t key);

int32_t tlsbox_rsa_fromprivkey(const char *buffer, size_t size);

int32_t tlsbox_rsa_frompubkey(const char *buffer, size_t size);

int32_t tlsbox_rsa_genkey(size_t key_size, int32_t exponent);

int tlsbox_rsa_getprivkey(int32_t key, char *buffer, size_t size);

int tlsbox_rsa_getpubkey(int32_t key, char *buffer, size_t size);

ssize_t tlsbox_rsa_pkcs1_decrypt(int32_t key, const void *input, void *output, size_t output_size);

int tlsbox_rsa_pkcs1_encrypt(int32_t key, const void *input, size_t input_size, void *output);

//// box exports ////

extern ssize_t __box_write(int32_t a0, const void *buffer, size_t size);

extern int bobbox_alicebox_getpubkey(char *buffer, size_t size);

extern int alicebox_bobbox_getpubkey(char *buffer, size_t size);

extern ssize_t sys_entropy_poll(void *buffer, size_t size);

extern int sys_rsa_freekey(int32_t box, int32_t key);

extern int sys_rsa_freekey(int32_t box, int32_t key);

extern int32_t sys_rsa_fromprivkey(int32_t box, const char *buffer, size_t size);

extern int32_t sys_rsa_fromprivkey(int32_t box, const char *buffer, size_t size);

extern int32_t sys_rsa_frompubkey(int32_t box, const char *buffer, size_t size);

extern int32_t sys_rsa_frompubkey(int32_t box, const char *buffer, size_t size);

extern int32_t sys_rsa_genkey(int32_t box, size_t key_size, int32_t exponent);

extern int32_t sys_rsa_genkey(int32_t box, size_t key_size, int32_t exponent);

extern int sys_rsa_getprivkey(int32_t box, int32_t key, char *buffer, size_t size);

extern int sys_rsa_getprivkey(int32_t box, int32_t key, char *buffer, size_t size);

extern int sys_rsa_getpubkey(int32_t box, int32_t key, char *buffer, size_t size);

extern int sys_rsa_getpubkey(int32_t box, int32_t key, char *buffer, size_t size);

extern ssize_t sys_rsa_pkcs1_decrypt(int32_t box, int32_t key, const void *input, void *output, size_t output_size);

extern ssize_t sys_rsa_pkcs1_decrypt(int32_t box, int32_t key, const void *input, void *output, size_t output_size);

extern int sys_rsa_pkcs1_encrypt(int32_t box, int32_t key, const void *input, size_t input_size, void *output);

extern int sys_rsa_pkcs1_encrypt(int32_t box, int32_t key, const void *input, size_t input_size, void *output);

extern int sys_send_to_alice(const void *buffer, size_t size);

extern int sys_send_to_bob(const void *buffer, size_t size);

//// box hooks ////

// Initialize box alicebox. Resets the box to its initial state if already
// initialized.
int __box_alicebox_init(void);

// Mark the box alicebox as needing to be reinitialized.
int __box_alicebox_clobber(void);

// Allocate size bytes on the box's data stack. May return NULL if a stack
// overflow would occur.
void *__box_alicebox_push(size_t size);

// Deallocate size bytes on the box's data stack.
void __box_alicebox_pop(size_t size);

// Initialize box bobbox. Resets the box to its initial state if already
// initialized.
int __box_bobbox_init(void);

// Mark the box bobbox as needing to be reinitialized.
int __box_bobbox_clobber(void);

// Allocate size bytes on the box's data stack. May return NULL if a stack
// overflow would occur.
void *__box_bobbox_push(size_t size);

// Deallocate size bytes on the box's data stack.
void __box_bobbox_pop(size_t size);

// Initialize box tlsbox. Resets the box to its initial state if already
// initialized.
int __box_tlsbox_init(void);

// Mark the box tlsbox as needing to be reinitialized.
int __box_tlsbox_clobber(void);

// Allocate size bytes on the box's data stack. May return NULL if a stack
// overflow would occur.
void *__box_tlsbox_push(size_t size);

// Deallocate size bytes on the box's data stack.
void __box_tlsbox_pop(size_t size);

// May be called by well-behaved code to terminate the box if execution can
// not continue. Notably used for asserts. Note that __box_abort may be
// skipped if the box is killed because of an illegal operation. Must not
// return.
__attribute__((noreturn))
void __box_abort(int err);

// Provides a minimal implementation of stdout to the box. The exact behavior
// depends on the superbox's implementation of __box_write. If none is
// provided, __box_write links but does nothing.
ssize_t __box_write(int32_t fd, const void *buffer, size_t size);

// Provides a minimal implementation of stdout to the box. The exact behavior
// depends on the superbox's implementation of __box_flush. If none is
// provided, __box_flush links but does nothing.
int __box_flush(int32_t fd);

//// box error codes ////
enum box_errors {
    EOK              = 0,    // No error
    EGENERAL         = 1,    // General error
    ENOENT           = 2,    // No such file or directory
    ESRCH            = 3,    // No such process
    EINTR            = 4,    // Interrupted system call
    EIO              = 5,    // I/O error
    ENXIO            = 6,    // No such device or address
    E2BIG            = 7,    // Argument list too long
    ENOEXEC          = 8,    // Exec format error
    EBADF            = 9,    // Bad file number
    ECHILD           = 10,   // No child processes
    EAGAIN           = 11,   // Try again
    ENOMEM           = 12,   // Out of memory
    EACCES           = 13,   // Permission denied
    EFAULT           = 14,   // Bad address
    EBUSY            = 16,   // Device or resource busy
    EEXIST           = 17,   // File exists
    EXDEV            = 18,   // Cross-device link
    ENODEV           = 19,   // No such device
    ENOTDIR          = 20,   // Not a directory
    EISDIR           = 21,   // Is a directory
    EINVAL           = 22,   // Invalid argument
    ENFILE           = 23,   // File table overflow
    EMFILE           = 24,   // Too many open files
    ENOTTY           = 25,   // Not a typewriter
    ETXTBSY          = 26,   // Text file busy
    EFBIG            = 27,   // File too large
    ENOSPC           = 28,   // No space left on device
    ESPIPE           = 29,   // Illegal seek
    EROFS            = 30,   // Read-only file system
    EMLINK           = 31,   // Too many links
    EPIPE            = 32,   // Broken pipe
    EDOM             = 33,   // Math argument out of domain of func
    ERANGE           = 34,   // Math result not representable
    EDEADLK          = 35,   // Resource deadlock would occur
    ENAMETOOLONG     = 36,   // File name too long
    ENOLCK           = 37,   // No record locks available
    ENOSYS           = 38,   // Function not implemented
    ENOTEMPTY        = 39,   // Directory not empty
    ELOOP            = 40,   // Too many symbolic links encountered
    ENOMSG           = 42,   // No message of desired type
    EIDRM            = 43,   // Identifier removed
    ENOSTR           = 60,   // Device not a stream
    ENODATA          = 61,   // No data available
    ETIME            = 62,   // Timer expired
    ENOSR            = 63,   // Out of streams resources
    ENOLINK          = 67,   // Link has been severed
    EPROTO           = 71,   // Protocol error
    EMULTIHOP        = 72,   // Multihop attempted
    EBADMSG          = 74,   // Not a data message
    EOVERFLOW        = 75,   // Value too large for defined data type
    EILSEQ           = 84,   // Illegal byte sequence
    ENOTSOCK         = 88,   // Socket operation on non-socket
    EDESTADDRREQ     = 89,   // Destination address required
    EMSGSIZE         = 90,   // Message too long
    EPROTOTYPE       = 91,   // Protocol wrong type for socket
    ENOPROTOOPT      = 92,   // Protocol not available
    EPROTONOSUPPORT  = 93,   // Protocol not supported
    EOPNOTSUPP       = 95,   // Operation not supported on transport endpoint
    EAFNOSUPPORT     = 97,   // Address family not supported by protocol
    EADDRINUSE       = 98,   // Address already in use
    EADDRNOTAVAIL    = 99,   // Cannot assign requested address
    ENETDOWN         = 100,  // Network is down
    ENETUNREACH      = 101,  // Network is unreachable
    ENETRESET        = 102,  // Network dropped connection because of reset
    ECONNABORTED     = 103,  // Software caused connection abort
    ECONNRESET       = 104,  // Connection reset by peer
    ENOBUFS          = 105,  // No buffer space available
    EISCONN          = 106,  // Transport endpoint is already connected
    ENOTCONN         = 107,  // Transport endpoint is not connected
    ETIMEDOUT        = 110,  // Connection timed out
    ECONNREFUSED     = 111,  // Connection refused
    EHOSTUNREACH     = 113,  // No route to host
    EALREADY         = 114,  // Operation already in progress
    EINPROGRESS      = 115,  // Operation now in progress
    ESTALE           = 116,  // Stale NFS file handle
    EDQUOT           = 122,  // Quota exceeded
    ECANCELED        = 125,  // Operation Canceled
    EOWNERDEAD       = 130,  // Owner died
    ENOTRECOVERABLE  = 131,  // State not recoverable
};

__attribute__((unused))
static int __box_wasm3_toerr(M3Result res) {
    // note we can't use switch/case here because these are pointers
    if      (res == m3Err_none)                             return 0;
    // general errors
    else if (res == m3Err_typeListOverflow)                 return -ENOMEM;
    else if (res == m3Err_mallocFailed)                     return -ENOMEM;
    // parse errors
    else if (res == m3Err_incompatibleWasmVersion)          return -ENOEXEC;
    else if (res == m3Err_wasmMalformed)                    return -ENOEXEC;
    else if (res == m3Err_misorderedWasmSection)            return -ENOEXEC;
    else if (res == m3Err_wasmUnderrun)                     return -ENOEXEC;
    else if (res == m3Err_wasmOverrun)                      return -ENOEXEC;
    else if (res == m3Err_wasmMissingInitExpr)              return -ENOEXEC;
    else if (res == m3Err_lebOverflow)                      return -ENOEXEC;
    else if (res == m3Err_missingUTF8)                      return -ENOEXEC;
    else if (res == m3Err_wasmSectionUnderrun)              return -ENOEXEC;
    else if (res == m3Err_wasmSectionOverrun)               return -ENOEXEC;
    else if (res == m3Err_invalidTypeId)                    return -ENOEXEC;
    else if (res == m3Err_tooManyMemorySections)            return -ENOEXEC;
    // link errors
    else if (res == m3Err_moduleAlreadyLinked)              return -ENOEXEC;
    else if (res == m3Err_functionLookupFailed)             return -ENOEXEC;
    else if (res == m3Err_functionImportMissing)            return -ENOEXEC;
    else if (res == m3Err_malformedFunctionSignature)       return -ENOEXEC;
    else if (res == m3Err_funcSignatureMissingReturnType)   return -ENOEXEC;
    // compilation errors
    else if (res == m3Err_noCompiler)                       return -ENOEXEC;
    else if (res == m3Err_unknownOpcode)                    return -ENOEXEC;
    else if (res == m3Err_functionStackOverflow)            return -EOVERFLOW;
    else if (res == m3Err_functionStackUnderrun)            return -ENOEXEC;
    else if (res == m3Err_mallocFailedCodePage)             return -ENOMEM;
    else if (res == m3Err_settingImmutableGlobal)           return -ENOEXEC;
    else if (res == m3Err_optimizerFailed)                  return -ENOEXEC;
    // runtime errors
    else if (res == m3Err_missingCompiledCode)              return -ENOEXEC;
    else if (res == m3Err_wasmMemoryOverflow)               return -ENOEXEC;
    else if (res == m3Err_globalMemoryNotAllocated)         return -ENOEXEC;
    else if (res == m3Err_globaIndexOutOfBounds)            return -ENOEXEC;
    else if (res == m3Err_argumentCountMismatch)            return -ENOEXEC;
    // traps
    else if (res == m3Err_trapOutOfBoundsMemoryAccess)      return -EFAULT;
    else if (res == m3Err_trapDivisionByZero)               return -EDOM;
    else if (res == m3Err_trapIntegerOverflow)              return -ERANGE;
    else if (res == m3Err_trapIntegerConversion)            return -ERANGE;
    else if (res == m3Err_trapIndirectCallTypeMismatch)     return -ENOEXEC;
    else if (res == m3Err_trapTableIndexOutOfRange)         return -EFAULT;
    else if (res == m3Err_trapTableElementIsNull)           return -EFAULT;
    else if (res == m3Err_trapExit)                         return -ECANCELED;
    else if (res == m3Err_trapAbort)                        return -ECANCELED;
    else if (res == m3Err_trapUnreachable)                  return -EFAULT;
    else if (res == m3Err_trapStackOverflow)                return -EOVERFLOW;
    // fallback to general error?
    else                                                    return -EGENERAL;
}

#if defined(__GNUC__)
// state of brk
static uint8_t *__heap_brk = NULL;
// assigned by linker
extern uint8_t __heap_start;
extern uint8_t __heap_end;

// GCC's _sbrk uses sp for bounds checking, this
// does not work if our stack is located before the heap
void *_sbrk(ptrdiff_t diff) {
    if (!__heap_brk) {
        __heap_brk = &__heap_start;
    }

    uint8_t *pbrk = __heap_brk;
    if (pbrk + diff > &__heap_end) {
        return (void*)-1;
    }

    __heap_brk = pbrk+diff;
    return pbrk;
}
#endif

//// __box_abort glue ////

__attribute__((noreturn))
void __box_abort(int err) {
    // if there's no other course of action, we spin
    while (1) {}
}

__attribute__((used))
__attribute__((noreturn))
void __wrap_abort(void) {
    __box_abort(-1);
}

__attribute__((used))
void __wrap_exit(int code) {
    __box_abort(code > 0 ? -code : code);
}

#if defined(__GNUC__)
__attribute__((noreturn))
void __assert_func(const char *file, int line,
        const char *func, const char *expr) {
    printf("%s:%d: assertion \"%s\" failed\n", file, line, expr);
    __box_abort(-1);
}

__attribute__((noreturn))
void _exit(int code) {
    __box_abort(code > 0 ? -code : code);
}
#endif

//// __box_write glue ////

int __box_flush(int32_t fd) {
    return 0;
}

ssize_t __box_cbprintf(
        ssize_t (*write)(void *ctx, const void *buf, size_t size), void *ctx,
        const char *format, va_list args) {
    const char *p = format;
    ssize_t res = 0;
    while (true) {
        // first consume everything until a '%'
        size_t skip = strcspn(p, "%");
        if (skip > 0) {
            ssize_t nres = write(ctx, p, skip);
            if (nres < 0) {
                return nres;
            }
            res += nres;
        }

        p += skip;

        // hit end of string?
        if (!*p) {
            return res;
        }

        // format parser
        bool zero_justify = false;
        bool left_justify = false;
        bool precision_mode = false;
        size_t width = 0;
        size_t precision = 0;

        char mode = 'c';
        uint32_t value = 0;
        size_t size = 0;

        for (;; p++) {
            if (p[1] >= '0' && p[1] <= '9') {
                // precision/width
                if (precision_mode) {
                    precision = precision*10 + (p[1]-'0');
                } else if (p[1] > '0' || width > 0) {
                    width = width*10 + (p[1]-'0');
                } else {
                    zero_justify = true;
                }

            } else if (p[1] == '*') {
                // dynamic precision/width
                if (precision_mode) {
                    precision = va_arg(args, size_t);
                } else {
                    width = va_arg(args, size_t);
                }

            } else if (p[1] == '.') {
                // switch mode
                precision_mode = true;

            } else if (p[1] == '-') {
                // left-justify
                left_justify = true;

            } else if (p[1] == '%') {
                // single '%'
                mode = 'c';
                value = '%';
                size = 1;
                break;

            } else if (p[1] == 'c') {
                // char
                mode = 'c';
                value = va_arg(args, int);
                size = 1;
                break;

            } else if (p[1] == 's') {
                // string
                mode = 's';
                const char *s = va_arg(args, const char *);
                value = (uint32_t)s;
                // find size, don't allow overruns
                size = 0;
                while (s[size] && (precision == 0 || size < precision)) {
                    size += 1;
                }
                break;

            } else if (p[1] == 'd' || p[1] == 'i') {
                // signed decimal number
                mode = 'd';
                int32_t d = va_arg(args, int32_t);
                value = (uint32_t)d;
                size = 0;
                if (d < 0) {
                    size += 1;
                    d = -d;
                }
                for (uint32_t t = d; t > 0; t /= 10) {
                    size += 1;
                }
                if (size == 0) {
                    size += 1;
                }
                break;

            } else if (p[1] == 'u') {
                // unsigned decimal number
                mode = 'u';
                value = va_arg(args, uint32_t);
                size = 0;
                for (uint32_t t = value; t > 0; t /= 10) {
                    size += 1;
                }
                if (size == 0) {
                    size += 1;
                }
                break;

            } else if (p[1] >= ' ' && p[1] <= '?') {
                // unknown modifier? skip

            } else {
                // hex or unknown character, terminate

                // make it prettier for pointers
                if (!(p[1] == 'x' || p[1] == 'X')) {
                    zero_justify = true;
                    width = 2*sizeof(void*);
                }

                // hexadecimal number
                mode = 'x';
                value = va_arg(args, uint32_t);
                size = 0;
                for (uint32_t t = value; t > 0; t /= 16) {
                    size += 1;
                }
                if (size == 0) {
                    size += 1;
                }
                break;
            }
        }

        // consume the format
        p += 2;

        // format printing
        if (!left_justify) {
            for (ssize_t i = 0; i < (ssize_t)width-(ssize_t)size; i++) {
                char c = (zero_justify) ? '0' : ' ';
                ssize_t nres = write(ctx, &c, 1);
                if (nres < 0) {
                    return nres;
                }
                res += nres;
            }
        }

        if (mode == 'c') {
            ssize_t nres = write(ctx, &value, 1);
            if (nres < 0) {
                return nres;
            }
            res += nres;
        } else if (mode == 's') {
            ssize_t nres = write(ctx, (const char*)(uintptr_t)value, size);
            if (nres < 0) {
                return nres;
            }
            res += nres;
        } else if (mode == 'x') {
            for (ssize_t i = size-1; i >= 0; i--) {
                uint32_t digit = (value >> (4*i)) & 0xf;

                char c = ((digit >= 10) ? ('a'-10) : '0') + digit;
                ssize_t nres = write(ctx, &c, 1);
                if (nres < 0) {
                    return nres;
                }
                res += nres;
            }
        } else if (mode == 'd' || mode == 'u') {
            ssize_t i = size-1;

            if (mode == 'd' && (int32_t)value < 0) {
                ssize_t nres = write(ctx, "-", 1);
                if (nres < 0) {
                    return nres;
                }
                res += nres;

                value = -value;
                i -= 1;
            }

            for (; i >= 0; i--) {
                uint32_t temp = value;
                for (int j = 0; j < i; j++) {
                    temp /= 10;
                }
                uint32_t digit = temp % 10;

                char c = '0' + digit;
                ssize_t nres = write(ctx, &c, 1);
                if (nres < 0) {
                    return nres;
                }
                res += nres;
            }
        }

        if (left_justify) {
            for (ssize_t i = 0; i < (ssize_t)width-(ssize_t)size; i++) {
                char c = ' ';
                ssize_t nres = write(ctx, &c, 1);
                if (nres < 0) {
                    return nres;
                }
                res += nres;
            }
        }
    }
}

static ssize_t __box_vprintf_write(void *ctx, const void *buf, size_t size) {
    return __box_write((int32_t)ctx, buf, size);
}

__attribute__((used))
ssize_t __wrap_vprintf(const char *format, va_list args) {
    return __box_cbprintf(__box_vprintf_write, (void*)1, format, args);
}

__attribute__((used))
ssize_t __wrap_printf(const char *format, ...) {
    va_list args;
    va_start(args, format);
    ssize_t res = __wrap_vprintf(format, args);
    va_end(args);
    return res;
}

__attribute__((used))
ssize_t __wrap_vfprintf(FILE *f, const char *format, va_list args) {
    int32_t fd = (f == stdout) ? 1 : 2;
    return __box_cbprintf(__box_vprintf_write, (void*)fd, format, args);
}

__attribute__((used))
ssize_t __wrap_fprintf(FILE *f, const char *format, ...) {
    va_list args;
    va_start(args, format);
    ssize_t res = __wrap_vfprintf(f, format, args);
    va_end(args);
    return res;
}

__attribute__((used))
int __wrap_fflush(FILE *f) {
    int32_t fd = (f == stdout) ? 1 : 2;
    return __box_flush(fd);
}

#if defined(__GNUC__)
int _write(int handle, const char *buffer, int size) {
    return __box_write(handle, (const uint8_t*)buffer, size);
}
#endif

//// ISR Vector definitions ////

extern void main(void);

// Reset Handler
__attribute__((naked, noreturn))
int32_t __box_reset_handler(void) {
    // load data
    extern uint32_t __data_init_start;
    extern uint32_t __data_start;
    extern uint32_t __data_end;
    const uint32_t *s = &__data_init_start;
    for (uint32_t *d = &__data_start; d < &__data_end; d++) {
        *d = *s++;
    }

    // zero bss
    extern uint32_t __bss_start;
    extern uint32_t __bss_end;
    for (uint32_t *d = &__bss_start; d < &__bss_end; d++) {
        *d = 0;
    }


    // FPU bringup?
    #if defined(__VFP_FP__) && !defined(__SOFTFP__)
    #define CPACR ((volatile uint32_t*)0xe000ed88)
    *CPACR |= 0x00f00000;
    __asm__ volatile ("dsb");
    __asm__ volatile ("isb");
    #endif

    // init libc
    extern void __libc_init_array(void);
    __libc_init_array();

    // enter main
    main();

    // halt if main exits
    while (1) {
        __asm__ volatile ("wfi");
    }
}

//// Default handlers ////

__attribute__((naked, noreturn))
void __box_nmi_handler(void) {
    while (1) {}
}

__attribute__((naked, noreturn))
void __box_hardfault_handler(void) {
    while (1) {}
}

__attribute__((naked, noreturn))
void __box_memmanage_handler(void) {
    while (1) {}
}

__attribute__((naked, noreturn))
void __box_busfault_handler(void) {
    while (1) {}
}

__attribute__((naked, noreturn))
void __box_usagefault_handler(void) {
    while (1) {}
}

__attribute__((naked, noreturn))
void __box_svc_handler(void) {
    while (1) {}
}

__attribute__((naked, noreturn))
void __box_debugmon_handler(void) {
    while (1) {}
}

__attribute__((naked, noreturn))
void __box_pendsv_handler(void) {
    while (1) {}
}

__attribute__((naked, noreturn))
void __box_systick_handler(void) {
    while (1) {}
}

__attribute__((naked, noreturn))
void __box_default_handler(void) {
    while (1) {}
}



extern uint32_t __stack_end;

//// ISR Vector ////

__attribute__((used, section(".isr_vector")))
const uint32_t __isr_vector[256] = {
    (uint32_t)&__stack_end,
    (uint32_t)&__box_reset_handler,
    // Exception handlers
    (uint32_t)__box_nmi_handler,
    (uint32_t)__box_hardfault_handler,
    (uint32_t)__box_memmanage_handler,
    (uint32_t)__box_busfault_handler,
    (uint32_t)__box_usagefault_handler,
    (uint32_t)0,
    (uint32_t)0,
    (uint32_t)0,
    (uint32_t)0,
    (uint32_t)__box_svc_handler,
    (uint32_t)__box_debugmon_handler,
    (uint32_t)0,
    (uint32_t)__box_pendsv_handler,
    (uint32_t)__box_systick_handler,
    // External IRQ handlers
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
};

//// alicebox loading ////

static int __box_alicebox_load(void) {
    // default loader does nothing
    return 0;
}

//// alicebox state ////
bool __box_alicebox_initialized = false;
IM3Environment __box_alicebox_environment;
IM3Runtime __box_alicebox_runtime;
IM3Module __box_alicebox_module;
uint8_t *__box_alicebox_datasp;

__attribute__((unused))
static uint32_t __box_alicebox_fromptr(const void *ptr) {
    return (uint32_t)((const uint8_t*)ptr
        - m3MemData(__box_alicebox_runtime->memory.mallocated));
}

__attribute__((unused))
static void *__box_alicebox_toptr(uint32_t ptr) {
    return m3MemData(__box_alicebox_runtime->memory.mallocated) + ptr;
}

void *__box_alicebox_push(size_t size) {
    // we maintain a separate stack in the wasm memory space,
    // sharing the stack space of the wasm-side libc
    uint8_t *psp = __box_alicebox_datasp;
    if (psp + size > (uint8_t*)__box_alicebox_toptr(16384)) {
        return NULL;
    }

    __box_alicebox_datasp = psp + size;
    return psp;
}

void __box_alicebox_pop(size_t size) {
    assert(__box_alicebox_datasp - size >= (uint8_t*)__box_alicebox_toptr(0));
    __box_alicebox_datasp -= size;
}

m3ApiRawFunction(__box_alicebox_import___box_alicebox_abort) {
    m3ApiGetArg(int, err);
    __box_alicebox_runtime->exit_code = err;
    m3ApiTrap(m3Err_trapExit);
}

// redirect __box_alicebox_write -> __box_write
#define __box_alicebox_write __box_write

// redirect __box_alicebox_flush -> __box_flush
#define __box_alicebox_flush __box_flush

//// alicebox imports ////

m3ApiRawFunction(__box_alicebox_import___box_alicebox_write) {
    m3ApiReturnType(ssize_t);
    m3ApiGetArg(int32_t, a0);
    m3ApiGetArgMem(const void*, a1);
    m3ApiGetArg(size_t, a2);
    ssize_t r0 = __box_alicebox_write(a0, a1, a2);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_alicebox_import___box_alicebox_flush) {
    m3ApiReturnType(int);
    m3ApiGetArg(int32_t, a0);
    int r0 = __box_alicebox_flush(a0);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_alicebox_import_alicebox_bobbox_getpubkey) {
    m3ApiReturnType(int);
    m3ApiGetArgMem(char*, buffer);
    m3ApiGetArg(size_t, size);
    int r0 = alicebox_bobbox_getpubkey(buffer, size);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_alicebox_import_sys_rsa_freekey) {
    m3ApiReturnType(int);
    m3ApiGetArg(int32_t, key);
    int r0 = sys_rsa_freekey(1, key);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_alicebox_import_sys_rsa_fromprivkey) {
    m3ApiReturnType(int32_t);
    m3ApiGetArgMem(const char*, buffer);
    m3ApiGetArg(size_t, size);
    int32_t key = sys_rsa_fromprivkey(1, buffer, size);
    m3ApiReturn(key);
}

m3ApiRawFunction(__box_alicebox_import_sys_rsa_frompubkey) {
    m3ApiReturnType(int32_t);
    m3ApiGetArgMem(const char*, buffer);
    m3ApiGetArg(size_t, size);
    int32_t key = sys_rsa_frompubkey(1, buffer, size);
    m3ApiReturn(key);
}

m3ApiRawFunction(__box_alicebox_import_sys_rsa_genkey) {
    m3ApiReturnType(int32_t);
    m3ApiGetArg(size_t, key_size);
    m3ApiGetArg(int32_t, exponent);
    int32_t key = sys_rsa_genkey(1, key_size, exponent);
    m3ApiReturn(key);
}

m3ApiRawFunction(__box_alicebox_import_sys_rsa_getprivkey) {
    m3ApiReturnType(int);
    m3ApiGetArg(int32_t, key);
    m3ApiGetArgMem(char*, buffer);
    m3ApiGetArg(size_t, size);
    int r0 = sys_rsa_getprivkey(1, key, buffer, size);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_alicebox_import_sys_rsa_getpubkey) {
    m3ApiReturnType(int);
    m3ApiGetArg(int32_t, key);
    m3ApiGetArgMem(char*, buffer);
    m3ApiGetArg(size_t, size);
    int r0 = sys_rsa_getpubkey(1, key, buffer, size);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_alicebox_import_sys_rsa_pkcs1_decrypt) {
    m3ApiReturnType(ssize_t);
    m3ApiGetArg(int32_t, key);
    m3ApiGetArgMem(const void*, input);
    m3ApiGetArgMem(void*, output);
    m3ApiGetArg(size_t, output_size);
    ssize_t r0 = sys_rsa_pkcs1_decrypt(1, key, input, output, output_size);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_alicebox_import_sys_rsa_pkcs1_encrypt) {
    m3ApiReturnType(int);
    m3ApiGetArg(int32_t, key);
    m3ApiGetArgMem(const void*, input);
    m3ApiGetArg(size_t, input_size);
    m3ApiGetArgMem(void*, output);
    int r0 = sys_rsa_pkcs1_encrypt(1, key, input, input_size, output);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_alicebox_import_sys_send_to_bob) {
    m3ApiReturnType(int);
    m3ApiGetArgMem(const void*, buffer);
    m3ApiGetArg(size_t, size);
    int r0 = sys_send_to_bob(buffer, size);
    m3ApiReturn(r0);
}

//// alicebox exports ////

int alicebox_getpubkey(char *buffer, size_t size) {
    if (!__box_alicebox_initialized) {
        int err = __box_alicebox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_alicebox_runtime,
            "alicebox_getpubkey");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 2) return -ENOEXEC;
    uint64_t *stack = __box_alicebox_runtime->stack;
    *(uint32_t*)&stack[0] = __box_alicebox_fromptr(buffer);
    *(size_t*)&stack[1] = size;
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_alicebox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_alicebox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(int*)&stack[0];
}

int alicebox_init(void) {
    if (!__box_alicebox_initialized) {
        int err = __box_alicebox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_alicebox_runtime,
            "alicebox_init");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 0) return -ENOEXEC;
    uint64_t *stack = __box_alicebox_runtime->stack;
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_alicebox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_alicebox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(int*)&stack[0];
}

int alicebox_main(void) {
    if (!__box_alicebox_initialized) {
        int err = __box_alicebox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_alicebox_runtime,
            "alicebox_main");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 0) return -ENOEXEC;
    uint64_t *stack = __box_alicebox_runtime->stack;
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_alicebox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_alicebox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(int*)&stack[0];
}

int alicebox_recv(const void *buffer, size_t size) {
    if (!__box_alicebox_initialized) {
        int err = __box_alicebox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_alicebox_runtime,
            "alicebox_recv");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 2) return -ENOEXEC;
    uint64_t *stack = __box_alicebox_runtime->stack;
    *(uint32_t*)&stack[0] = __box_alicebox_fromptr(buffer);
    *(size_t*)&stack[1] = size;
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_alicebox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_alicebox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(int*)&stack[0];
}

//// alicebox init ////

int __box_alicebox_init(void) {
    int err;
    // load the box if unloaded
    err = __box_alicebox_load();
    if (err) {
        return err;
    }

    // initialized wasm3 runtime
    M3Result res;
    __box_alicebox_environment = m3_NewEnvironment();
    if (!__box_alicebox_environment) return -ENOMEM;
    __box_alicebox_runtime = m3_NewRuntime(
            __box_alicebox_environment,
            4096,
            NULL);
    if (!__box_alicebox_runtime) return -ENOMEM;
    extern uint32_t __box_alicebox_image;
    res = m3_ParseModule(
            __box_alicebox_environment,
            &__box_alicebox_module,
            (uint8_t*)(&__box_alicebox_image + 1),
            __box_alicebox_image);
    if (res) return __box_wasm3_toerr(res);

    res = m3_LoadModule(__box_alicebox_runtime, __box_alicebox_module);
    if (res) return __box_wasm3_toerr(res);

    // link imports
    res = m3_LinkRawFunction(
            __box_alicebox_module,
            "*",
            "__box_abort",
            "v(i)",
            __box_alicebox_import___box_alicebox_abort);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_alicebox_module,
            "*",
            "__box_write",
            "i(i*i)",
            __box_alicebox_import___box_alicebox_write);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_alicebox_module,
            "*",
            "__box_flush",
            "i(i)",
            __box_alicebox_import___box_alicebox_flush);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_alicebox_module,
            "*",
            "bobbox_getpubkey",
            "i(*i)",
            __box_alicebox_import_alicebox_bobbox_getpubkey);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_alicebox_module,
            "*",
            "sys_rsa_freekey",
            "i(ii)",
            __box_alicebox_import_sys_rsa_freekey);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_alicebox_module,
            "*",
            "sys_rsa_fromprivkey",
            "i(i*i)",
            __box_alicebox_import_sys_rsa_fromprivkey);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_alicebox_module,
            "*",
            "sys_rsa_frompubkey",
            "i(i*i)",
            __box_alicebox_import_sys_rsa_frompubkey);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_alicebox_module,
            "*",
            "sys_rsa_genkey",
            "i(iii)",
            __box_alicebox_import_sys_rsa_genkey);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_alicebox_module,
            "*",
            "sys_rsa_getprivkey",
            "i(ii*i)",
            __box_alicebox_import_sys_rsa_getprivkey);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_alicebox_module,
            "*",
            "sys_rsa_getpubkey",
            "i(ii*i)",
            __box_alicebox_import_sys_rsa_getpubkey);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_alicebox_module,
            "*",
            "sys_rsa_pkcs1_decrypt",
            "i(ii**i)",
            __box_alicebox_import_sys_rsa_pkcs1_decrypt);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_alicebox_module,
            "*",
            "sys_rsa_pkcs1_encrypt",
            "i(ii*i*)",
            __box_alicebox_import_sys_rsa_pkcs1_encrypt);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_alicebox_module,
            "*",
            "sys_send_to_bob",
            "i(*i)",
            __box_alicebox_import_sys_send_to_bob);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }

    // setup data stack
    __box_alicebox_datasp = __box_alicebox_toptr(0);

    __box_alicebox_initialized = true;
    return 0;
}

int __box_alicebox_clobber(void) {
    __box_alicebox_initialized = false;
    return 0;
}

//// bobbox loading ////

static int __box_bobbox_load(void) {
    // default loader does nothing
    return 0;
}

//// bobbox state ////
bool __box_bobbox_initialized = false;
IM3Environment __box_bobbox_environment;
IM3Runtime __box_bobbox_runtime;
IM3Module __box_bobbox_module;
uint8_t *__box_bobbox_datasp;

__attribute__((unused))
static uint32_t __box_bobbox_fromptr(const void *ptr) {
    return (uint32_t)((const uint8_t*)ptr
        - m3MemData(__box_bobbox_runtime->memory.mallocated));
}

__attribute__((unused))
static void *__box_bobbox_toptr(uint32_t ptr) {
    return m3MemData(__box_bobbox_runtime->memory.mallocated) + ptr;
}

void *__box_bobbox_push(size_t size) {
    // we maintain a separate stack in the wasm memory space,
    // sharing the stack space of the wasm-side libc
    uint8_t *psp = __box_bobbox_datasp;
    if (psp + size > (uint8_t*)__box_bobbox_toptr(16384)) {
        return NULL;
    }

    __box_bobbox_datasp = psp + size;
    return psp;
}

void __box_bobbox_pop(size_t size) {
    assert(__box_bobbox_datasp - size >= (uint8_t*)__box_bobbox_toptr(0));
    __box_bobbox_datasp -= size;
}

m3ApiRawFunction(__box_bobbox_import___box_bobbox_abort) {
    m3ApiGetArg(int, err);
    __box_bobbox_runtime->exit_code = err;
    m3ApiTrap(m3Err_trapExit);
}

// redirect __box_bobbox_write -> __box_write
#define __box_bobbox_write __box_write

// redirect __box_bobbox_flush -> __box_flush
#define __box_bobbox_flush __box_flush

//// bobbox imports ////

m3ApiRawFunction(__box_bobbox_import___box_bobbox_write) {
    m3ApiReturnType(ssize_t);
    m3ApiGetArg(int32_t, a0);
    m3ApiGetArgMem(const void*, a1);
    m3ApiGetArg(size_t, a2);
    ssize_t r0 = __box_bobbox_write(a0, a1, a2);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_bobbox_import___box_bobbox_flush) {
    m3ApiReturnType(int);
    m3ApiGetArg(int32_t, a0);
    int r0 = __box_bobbox_flush(a0);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_bobbox_import_bobbox_alicebox_getpubkey) {
    m3ApiReturnType(int);
    m3ApiGetArgMem(char*, buffer);
    m3ApiGetArg(size_t, size);
    int r0 = bobbox_alicebox_getpubkey(buffer, size);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_bobbox_import_sys_rsa_freekey) {
    m3ApiReturnType(int);
    m3ApiGetArg(int32_t, key);
    int r0 = sys_rsa_freekey(0, key);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_bobbox_import_sys_rsa_fromprivkey) {
    m3ApiReturnType(int32_t);
    m3ApiGetArgMem(const char*, buffer);
    m3ApiGetArg(size_t, size);
    int32_t key = sys_rsa_fromprivkey(0, buffer, size);
    m3ApiReturn(key);
}

m3ApiRawFunction(__box_bobbox_import_sys_rsa_frompubkey) {
    m3ApiReturnType(int32_t);
    m3ApiGetArgMem(const char*, buffer);
    m3ApiGetArg(size_t, size);
    int32_t key = sys_rsa_frompubkey(0, buffer, size);
    m3ApiReturn(key);
}

m3ApiRawFunction(__box_bobbox_import_sys_rsa_genkey) {
    m3ApiReturnType(int32_t);
    m3ApiGetArg(size_t, key_size);
    m3ApiGetArg(int32_t, exponent);
    int32_t key = sys_rsa_genkey(0, key_size, exponent);
    m3ApiReturn(key);
}

m3ApiRawFunction(__box_bobbox_import_sys_rsa_getprivkey) {
    m3ApiReturnType(int);
    m3ApiGetArg(int32_t, key);
    m3ApiGetArgMem(char*, buffer);
    m3ApiGetArg(size_t, size);
    int r0 = sys_rsa_getprivkey(0, key, buffer, size);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_bobbox_import_sys_rsa_getpubkey) {
    m3ApiReturnType(int);
    m3ApiGetArg(int32_t, key);
    m3ApiGetArgMem(char*, buffer);
    m3ApiGetArg(size_t, size);
    int r0 = sys_rsa_getpubkey(0, key, buffer, size);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_bobbox_import_sys_rsa_pkcs1_decrypt) {
    m3ApiReturnType(ssize_t);
    m3ApiGetArg(int32_t, key);
    m3ApiGetArgMem(const void*, input);
    m3ApiGetArgMem(void*, output);
    m3ApiGetArg(size_t, output_size);
    ssize_t r0 = sys_rsa_pkcs1_decrypt(0, key, input, output, output_size);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_bobbox_import_sys_rsa_pkcs1_encrypt) {
    m3ApiReturnType(int);
    m3ApiGetArg(int32_t, key);
    m3ApiGetArgMem(const void*, input);
    m3ApiGetArg(size_t, input_size);
    m3ApiGetArgMem(void*, output);
    int r0 = sys_rsa_pkcs1_encrypt(0, key, input, input_size, output);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_bobbox_import_sys_send_to_alice) {
    m3ApiReturnType(int);
    m3ApiGetArgMem(const void*, buffer);
    m3ApiGetArg(size_t, size);
    int r0 = sys_send_to_alice(buffer, size);
    m3ApiReturn(r0);
}

//// bobbox exports ////

int bobbox_getpubkey(char *buffer, size_t size) {
    if (!__box_bobbox_initialized) {
        int err = __box_bobbox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_bobbox_runtime,
            "bobbox_getpubkey");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 2) return -ENOEXEC;
    uint64_t *stack = __box_bobbox_runtime->stack;
    *(uint32_t*)&stack[0] = __box_bobbox_fromptr(buffer);
    *(size_t*)&stack[1] = size;
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_bobbox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_bobbox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(int*)&stack[0];
}

int bobbox_init(void) {
    if (!__box_bobbox_initialized) {
        int err = __box_bobbox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_bobbox_runtime,
            "bobbox_init");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 0) return -ENOEXEC;
    uint64_t *stack = __box_bobbox_runtime->stack;
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_bobbox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_bobbox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(int*)&stack[0];
}

int bobbox_main(void) {
    if (!__box_bobbox_initialized) {
        int err = __box_bobbox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_bobbox_runtime,
            "bobbox_main");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 0) return -ENOEXEC;
    uint64_t *stack = __box_bobbox_runtime->stack;
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_bobbox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_bobbox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(int*)&stack[0];
}

int bobbox_recv(const void *buffer, size_t size) {
    if (!__box_bobbox_initialized) {
        int err = __box_bobbox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_bobbox_runtime,
            "bobbox_recv");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 2) return -ENOEXEC;
    uint64_t *stack = __box_bobbox_runtime->stack;
    *(uint32_t*)&stack[0] = __box_bobbox_fromptr(buffer);
    *(size_t*)&stack[1] = size;
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_bobbox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_bobbox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(int*)&stack[0];
}

//// bobbox init ////

int __box_bobbox_init(void) {
    int err;
    // load the box if unloaded
    err = __box_bobbox_load();
    if (err) {
        return err;
    }

    // initialized wasm3 runtime
    M3Result res;
    __box_bobbox_environment = m3_NewEnvironment();
    if (!__box_bobbox_environment) return -ENOMEM;
    __box_bobbox_runtime = m3_NewRuntime(
            __box_bobbox_environment,
            4096,
            NULL);
    if (!__box_bobbox_runtime) return -ENOMEM;
    extern uint32_t __box_bobbox_image;
    res = m3_ParseModule(
            __box_bobbox_environment,
            &__box_bobbox_module,
            (uint8_t*)(&__box_bobbox_image + 1),
            __box_bobbox_image);
    if (res) return __box_wasm3_toerr(res);

    res = m3_LoadModule(__box_bobbox_runtime, __box_bobbox_module);
    if (res) return __box_wasm3_toerr(res);

    // link imports
    res = m3_LinkRawFunction(
            __box_bobbox_module,
            "*",
            "__box_abort",
            "v(i)",
            __box_bobbox_import___box_bobbox_abort);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_bobbox_module,
            "*",
            "__box_write",
            "i(i*i)",
            __box_bobbox_import___box_bobbox_write);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_bobbox_module,
            "*",
            "__box_flush",
            "i(i)",
            __box_bobbox_import___box_bobbox_flush);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_bobbox_module,
            "*",
            "alicebox_getpubkey",
            "i(*i)",
            __box_bobbox_import_bobbox_alicebox_getpubkey);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_bobbox_module,
            "*",
            "sys_rsa_freekey",
            "i(ii)",
            __box_bobbox_import_sys_rsa_freekey);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_bobbox_module,
            "*",
            "sys_rsa_fromprivkey",
            "i(i*i)",
            __box_bobbox_import_sys_rsa_fromprivkey);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_bobbox_module,
            "*",
            "sys_rsa_frompubkey",
            "i(i*i)",
            __box_bobbox_import_sys_rsa_frompubkey);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_bobbox_module,
            "*",
            "sys_rsa_genkey",
            "i(iii)",
            __box_bobbox_import_sys_rsa_genkey);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_bobbox_module,
            "*",
            "sys_rsa_getprivkey",
            "i(ii*i)",
            __box_bobbox_import_sys_rsa_getprivkey);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_bobbox_module,
            "*",
            "sys_rsa_getpubkey",
            "i(ii*i)",
            __box_bobbox_import_sys_rsa_getpubkey);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_bobbox_module,
            "*",
            "sys_rsa_pkcs1_decrypt",
            "i(ii**i)",
            __box_bobbox_import_sys_rsa_pkcs1_decrypt);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_bobbox_module,
            "*",
            "sys_rsa_pkcs1_encrypt",
            "i(ii*i*)",
            __box_bobbox_import_sys_rsa_pkcs1_encrypt);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_bobbox_module,
            "*",
            "sys_send_to_alice",
            "i(*i)",
            __box_bobbox_import_sys_send_to_alice);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }

    // setup data stack
    __box_bobbox_datasp = __box_bobbox_toptr(0);

    __box_bobbox_initialized = true;
    return 0;
}

int __box_bobbox_clobber(void) {
    __box_bobbox_initialized = false;
    return 0;
}

//// tlsbox loading ////

static int __box_tlsbox_load(void) {
    // default loader does nothing
    return 0;
}

//// tlsbox state ////
bool __box_tlsbox_initialized = false;
IM3Environment __box_tlsbox_environment;
IM3Runtime __box_tlsbox_runtime;
IM3Module __box_tlsbox_module;
uint8_t *__box_tlsbox_datasp;

__attribute__((unused))
static uint32_t __box_tlsbox_fromptr(const void *ptr) {
    return (uint32_t)((const uint8_t*)ptr
        - m3MemData(__box_tlsbox_runtime->memory.mallocated));
}

__attribute__((unused))
static void *__box_tlsbox_toptr(uint32_t ptr) {
    return m3MemData(__box_tlsbox_runtime->memory.mallocated) + ptr;
}

void *__box_tlsbox_push(size_t size) {
    // we maintain a separate stack in the wasm memory space,
    // sharing the stack space of the wasm-side libc
    uint8_t *psp = __box_tlsbox_datasp;
    if (psp + size > (uint8_t*)__box_tlsbox_toptr(65536)) {
        return NULL;
    }

    __box_tlsbox_datasp = psp + size;
    return psp;
}

void __box_tlsbox_pop(size_t size) {
    assert(__box_tlsbox_datasp - size >= (uint8_t*)__box_tlsbox_toptr(0));
    __box_tlsbox_datasp -= size;
}

m3ApiRawFunction(__box_tlsbox_import___box_tlsbox_abort) {
    m3ApiGetArg(int, err);
    __box_tlsbox_runtime->exit_code = err;
    m3ApiTrap(m3Err_trapExit);
}

// redirect __box_tlsbox_write -> __box_write
#define __box_tlsbox_write __box_write

// redirect __box_tlsbox_flush -> __box_flush
#define __box_tlsbox_flush __box_flush

//// tlsbox imports ////

m3ApiRawFunction(__box_tlsbox_import___box_tlsbox_write) {
    m3ApiReturnType(ssize_t);
    m3ApiGetArg(int32_t, a0);
    m3ApiGetArgMem(const void*, a1);
    m3ApiGetArg(size_t, a2);
    ssize_t r0 = __box_tlsbox_write(a0, a1, a2);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_tlsbox_import___box_tlsbox_flush) {
    m3ApiReturnType(int);
    m3ApiGetArg(int32_t, a0);
    int r0 = __box_tlsbox_flush(a0);
    m3ApiReturn(r0);
}

m3ApiRawFunction(__box_tlsbox_import_sys_entropy_poll) {
    m3ApiReturnType(ssize_t);
    m3ApiGetArgMem(void*, buffer);
    m3ApiGetArg(size_t, size);
    ssize_t r0 = sys_entropy_poll(buffer, size);
    m3ApiReturn(r0);
}

//// tlsbox exports ////

int tlsbox_drbg_seed(void) {
    if (!__box_tlsbox_initialized) {
        int err = __box_tlsbox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_tlsbox_runtime,
            "tlsbox_drbg_seed");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 0) return -ENOEXEC;
    uint64_t *stack = __box_tlsbox_runtime->stack;
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_tlsbox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_tlsbox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(int*)&stack[0];
}

int tlsbox_rsa_freekey(int32_t key) {
    if (!__box_tlsbox_initialized) {
        int err = __box_tlsbox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_tlsbox_runtime,
            "tlsbox_rsa_freekey");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 1) return -ENOEXEC;
    uint64_t *stack = __box_tlsbox_runtime->stack;
    *(int32_t*)&stack[0] = key;
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_tlsbox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_tlsbox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(int*)&stack[0];
}

int32_t tlsbox_rsa_fromprivkey(const char *buffer, size_t size) {
    if (!__box_tlsbox_initialized) {
        int err = __box_tlsbox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_tlsbox_runtime,
            "tlsbox_rsa_fromprivkey");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 2) return -ENOEXEC;
    uint64_t *stack = __box_tlsbox_runtime->stack;
    *(uint32_t*)&stack[0] = __box_tlsbox_fromptr(buffer);
    *(size_t*)&stack[1] = size;
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_tlsbox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_tlsbox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(int32_t*)&stack[0];
}

int32_t tlsbox_rsa_frompubkey(const char *buffer, size_t size) {
    if (!__box_tlsbox_initialized) {
        int err = __box_tlsbox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_tlsbox_runtime,
            "tlsbox_rsa_frompubkey");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 2) return -ENOEXEC;
    uint64_t *stack = __box_tlsbox_runtime->stack;
    *(uint32_t*)&stack[0] = __box_tlsbox_fromptr(buffer);
    *(size_t*)&stack[1] = size;
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_tlsbox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_tlsbox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(int32_t*)&stack[0];
}

int32_t tlsbox_rsa_genkey(size_t key_size, int32_t exponent) {
    if (!__box_tlsbox_initialized) {
        int err = __box_tlsbox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_tlsbox_runtime,
            "tlsbox_rsa_genkey");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 2) return -ENOEXEC;
    uint64_t *stack = __box_tlsbox_runtime->stack;
    *(size_t*)&stack[0] = key_size;
    *(int32_t*)&stack[1] = exponent;
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_tlsbox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_tlsbox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(int32_t*)&stack[0];
}

int tlsbox_rsa_getprivkey(int32_t key, char *buffer, size_t size) {
    if (!__box_tlsbox_initialized) {
        int err = __box_tlsbox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_tlsbox_runtime,
            "tlsbox_rsa_getprivkey");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 3) return -ENOEXEC;
    uint64_t *stack = __box_tlsbox_runtime->stack;
    *(int32_t*)&stack[0] = key;
    *(uint32_t*)&stack[1] = __box_tlsbox_fromptr(buffer);
    *(size_t*)&stack[2] = size;
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_tlsbox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_tlsbox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(int*)&stack[0];
}

int tlsbox_rsa_getpubkey(int32_t key, char *buffer, size_t size) {
    if (!__box_tlsbox_initialized) {
        int err = __box_tlsbox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_tlsbox_runtime,
            "tlsbox_rsa_getpubkey");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 3) return -ENOEXEC;
    uint64_t *stack = __box_tlsbox_runtime->stack;
    *(int32_t*)&stack[0] = key;
    *(uint32_t*)&stack[1] = __box_tlsbox_fromptr(buffer);
    *(size_t*)&stack[2] = size;
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_tlsbox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_tlsbox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(int*)&stack[0];
}

ssize_t tlsbox_rsa_pkcs1_decrypt(int32_t key, const void *input, void *output, size_t output_size) {
    if (!__box_tlsbox_initialized) {
        int err = __box_tlsbox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_tlsbox_runtime,
            "tlsbox_rsa_pkcs1_decrypt");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 4) return -ENOEXEC;
    uint64_t *stack = __box_tlsbox_runtime->stack;
    *(int32_t*)&stack[0] = key;
    *(uint32_t*)&stack[1] = __box_tlsbox_fromptr(input);
    *(uint32_t*)&stack[2] = __box_tlsbox_fromptr(output);
    *(size_t*)&stack[3] = output_size;
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_tlsbox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_tlsbox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(ssize_t*)&stack[0];
}

int tlsbox_rsa_pkcs1_encrypt(int32_t key, const void *input, size_t input_size, void *output) {
    if (!__box_tlsbox_initialized) {
        int err = __box_tlsbox_init();
        if (err) {
            return err;
        }
    }

    M3Result res;
    IM3Function f;
    res = m3_FindFunction(&f,
            __box_tlsbox_runtime,
            "tlsbox_rsa_pkcs1_encrypt");
    if (res || !f->compiled) return -ENOEXEC;
    if (f->funcType->numArgs != 4) return -ENOEXEC;
    uint64_t *stack = __box_tlsbox_runtime->stack;
    *(int32_t*)&stack[0] = key;
    *(uint32_t*)&stack[1] = __box_tlsbox_fromptr(input);
    *(size_t*)&stack[2] = input_size;
    *(uint32_t*)&stack[3] = __box_tlsbox_fromptr(output);
    m3StackCheckInit();
    res = (M3Result)Call(
            f->compiled,
            (m3stack_t)stack,
            __box_tlsbox_runtime->memory.mallocated,
            d_m3OpDefaultArgs);
    if (res) {
        if (res == m3Err_trapExit) {
            return __box_tlsbox_runtime->exit_code;
        }
        return __box_wasm3_toerr(res);
    }
    return *(int*)&stack[0];
}

//// tlsbox init ////

int __box_tlsbox_init(void) {
    int err;
    // load the box if unloaded
    err = __box_tlsbox_load();
    if (err) {
        return err;
    }

    // initialized wasm3 runtime
    M3Result res;
    __box_tlsbox_environment = m3_NewEnvironment();
    if (!__box_tlsbox_environment) return -ENOMEM;
    __box_tlsbox_runtime = m3_NewRuntime(
            __box_tlsbox_environment,
            32768,
            NULL);
    if (!__box_tlsbox_runtime) return -ENOMEM;
    extern uint32_t __box_tlsbox_image;
    res = m3_ParseModule(
            __box_tlsbox_environment,
            &__box_tlsbox_module,
            (uint8_t*)(&__box_tlsbox_image + 1),
            __box_tlsbox_image);
    if (res) return __box_wasm3_toerr(res);

    res = m3_LoadModule(__box_tlsbox_runtime, __box_tlsbox_module);
    if (res) return __box_wasm3_toerr(res);

    // link imports
    res = m3_LinkRawFunction(
            __box_tlsbox_module,
            "*",
            "__box_abort",
            "v(i)",
            __box_tlsbox_import___box_tlsbox_abort);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_tlsbox_module,
            "*",
            "__box_write",
            "i(i*i)",
            __box_tlsbox_import___box_tlsbox_write);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_tlsbox_module,
            "*",
            "__box_flush",
            "i(i)",
            __box_tlsbox_import___box_tlsbox_flush);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }
    res = m3_LinkRawFunction(
            __box_tlsbox_module,
            "*",
            "sys_entropy_poll",
            "i(*i)",
            __box_tlsbox_import_sys_entropy_poll);
    if (res && res != m3Err_functionLookupFailed) {
        return __box_wasm3_toerr(res);
    }

    // setup data stack
    __box_tlsbox_datasp = __box_tlsbox_toptr(0);

    __box_tlsbox_initialized = true;
    return 0;
}

int __box_tlsbox_clobber(void) {
    __box_tlsbox_initialized = false;
    return 0;
}

