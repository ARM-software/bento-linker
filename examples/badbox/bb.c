////// AUTOGENERATED //////
#include <assert.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>

//// box imports ////

int32_t box1_add2(int32_t a0, int32_t a1);

int box1_badassert(void);

int box1_badread(void);

int box1_badwrite(void);

int box1_hello(void);

int box1_overflow(void);

//// box exports ////

extern ssize_t __box_write(int32_t a0, const void *a1, size_t size);

//// box hooks ////

// Initialize box box1. Resets the box to its initial state if already
// initialized.
int __box_box1_init(void);

// Mark the box box1 as needing to be reinitialized.
int __box_box1_clobber(void);

// Allocate size bytes on the box's data stack. May return NULL if a stack
// overflow would occur.
void *__box_box1_push(size_t size);

// Deallocate size bytes on the box's data stack.
void __box_box1_pop(size_t size);

// May be called by well-behaved code to terminate the box if execution can
// not continue. Notably used for asserts. Note that __box_abort may be
// skipped if the box is killed because of an illegal operation. Must not
// return.
__attribute__((noreturn))
void __box_abort(int err);

// Provides a minimal implementation of stdout to the box. The exact behavior
// depends on the superbox's implementation of __box_write. If none is
// provided, __box_write links but does nothing.
ssize_t __box_write(int32_t fd, const void *buffer, size_t size);

// Provides a minimal implementation of stdout to the box. The exact behavior
// depends on the superbox's implementation of __box_flush. If none is
// provided, __box_flush links but does nothing.
int __box_flush(int32_t fd);

//// box error codes ////
enum box_errors {
    EOK              = 0,    // No error
    EGENERAL         = 1,    // General error
    ENOENT           = 2,    // No such file or directory
    ESRCH            = 3,    // No such process
    EINTR            = 4,    // Interrupted system call
    EIO              = 5,    // I/O error
    ENXIO            = 6,    // No such device or address
    E2BIG            = 7,    // Argument list too long
    ENOEXEC          = 8,    // Exec format error
    EBADF            = 9,    // Bad file number
    ECHILD           = 10,   // No child processes
    EAGAIN           = 11,   // Try again
    ENOMEM           = 12,   // Out of memory
    EACCES           = 13,   // Permission denied
    EFAULT           = 14,   // Bad address
    EBUSY            = 16,   // Device or resource busy
    EEXIST           = 17,   // File exists
    EXDEV            = 18,   // Cross-device link
    ENODEV           = 19,   // No such device
    ENOTDIR          = 20,   // Not a directory
    EISDIR           = 21,   // Is a directory
    EINVAL           = 22,   // Invalid argument
    ENFILE           = 23,   // File table overflow
    EMFILE           = 24,   // Too many open files
    ENOTTY           = 25,   // Not a typewriter
    ETXTBSY          = 26,   // Text file busy
    EFBIG            = 27,   // File too large
    ENOSPC           = 28,   // No space left on device
    ESPIPE           = 29,   // Illegal seek
    EROFS            = 30,   // Read-only file system
    EMLINK           = 31,   // Too many links
    EPIPE            = 32,   // Broken pipe
    EDOM             = 33,   // Math argument out of domain of func
    ERANGE           = 34,   // Math result not representable
    EDEADLK          = 35,   // Resource deadlock would occur
    ENAMETOOLONG     = 36,   // File name too long
    ENOLCK           = 37,   // No record locks available
    ENOSYS           = 38,   // Function not implemented
    ENOTEMPTY        = 39,   // Directory not empty
    ELOOP            = 40,   // Too many symbolic links encountered
    ENOMSG           = 42,   // No message of desired type
    EIDRM            = 43,   // Identifier removed
    ENOSTR           = 60,   // Device not a stream
    ENODATA          = 61,   // No data available
    ETIME            = 62,   // Timer expired
    ENOSR            = 63,   // Out of streams resources
    ENOLINK          = 67,   // Link has been severed
    EPROTO           = 71,   // Protocol error
    EMULTIHOP        = 72,   // Multihop attempted
    EBADMSG          = 74,   // Not a data message
    EOVERFLOW        = 75,   // Value too large for defined data type
    EILSEQ           = 84,   // Illegal byte sequence
    ENOTSOCK         = 88,   // Socket operation on non-socket
    EDESTADDRREQ     = 89,   // Destination address required
    EMSGSIZE         = 90,   // Message too long
    EPROTOTYPE       = 91,   // Protocol wrong type for socket
    ENOPROTOOPT      = 92,   // Protocol not available
    EPROTONOSUPPORT  = 93,   // Protocol not supported
    EOPNOTSUPP       = 95,   // Operation not supported on transport endpoint
    EAFNOSUPPORT     = 97,   // Address family not supported by protocol
    EADDRINUSE       = 98,   // Address already in use
    EADDRNOTAVAIL    = 99,   // Cannot assign requested address
    ENETDOWN         = 100,  // Network is down
    ENETUNREACH      = 101,  // Network is unreachable
    ENETRESET        = 102,  // Network dropped connection because of reset
    ECONNABORTED     = 103,  // Software caused connection abort
    ECONNRESET       = 104,  // Connection reset by peer
    ENOBUFS          = 105,  // No buffer space available
    EISCONN          = 106,  // Transport endpoint is already connected
    ENOTCONN         = 107,  // Transport endpoint is not connected
    ETIMEDOUT        = 110,  // Connection timed out
    ECONNREFUSED     = 111,  // Connection refused
    EHOSTUNREACH     = 113,  // No route to host
    EALREADY         = 114,  // Operation already in progress
    EINPROGRESS      = 115,  // Operation now in progress
    ESTALE           = 116,  // Stale NFS file handle
    EDQUOT           = 122,  // Quota exceeded
    ECANCELED        = 125,  // Operation Canceled
    EOWNERDEAD       = 130,  // Owner died
    ENOTRECOVERABLE  = 131,  // State not recoverable
};

struct __box_mpuregions {
    uint32_t control;
    uint32_t count;
    uint32_t regions[][2];
};

uint32_t __box_active = 0;
extern uint32_t __box_callregion;
extern void __box_return(void);

#define SHCSR    ((volatile uint32_t*)0xe000ed24)
#define MPU_TYPE ((volatile uint32_t*)0xe000ed90)
#define MPU_CTRL ((volatile uint32_t*)0xe000ed94)
#define MPU_RBAR ((volatile uint32_t*)0xe000ed9c)
#define MPU_RASR ((volatile uint32_t*)0xe000eda0)
#define CCR      ((volatile uint32_t*)0xe000ed14)

static int32_t __box_mpu_init(void) {
    // make sure MPU is initialized
    if (!(*MPU_CTRL & 0x1)) {
        // do we have an MPU?
        assert(*MPU_TYPE >= 4);
        // enable MemManage exceptions
        *SHCSR = *SHCSR | 0x00070000;
        // setup call region
        *MPU_RBAR = (uint32_t)&__box_callregion | 0x10;
        // disallow execution
        //*MPU_RASR = 0x10230021;
        *MPU_RASR = 0x10000001 | ((6-1) << 1);
        // enable the MPU
        *MPU_CTRL = 5;
    }
    return 0;
}

static void __box_mpu_switch(const struct __box_mpuregions *regions) {
    // update MPU regions
    *MPU_CTRL = 0;
    uint32_t count = regions->count;
    for (int i = 0; i < 4; i++) {
        if (i < count) {
            *MPU_RBAR = regions->regions[i][0] | 0x10 | (i+1);
            *MPU_RASR = regions->regions[i][1];
        } else {
            *MPU_RBAR = 0x10 | (i+1);
            *MPU_RASR = 0;
        }
    }
    *MPU_CTRL = 5;

    // update CONTROL state, note that return-from-exception acts
    // as an instruction barrier
    uint32_t control;
    __asm__ volatile ("mrs %0, control" : "=r"(control));
    control = (~1 & control) | (regions->control);
    __asm__ volatile ("msr control, %0" :: "r"(control));
}

#define __BOX_COUNT 1

struct __box_state {
    bool initialized;
    uint32_t caller;
    uint32_t lr;
    uint32_t *sp;
};

//// __box_abort glue ////

__attribute__((noreturn))
void __box_abort(int err) {
    // if there's no other course of action, we spin
    while (1) {}
}

__attribute__((used, noreturn))
void __wrap_abort(void) {
    __box_abort(-1);
}

#ifdef __GNUC__
__attribute__((noreturn))
void __assert_func(const char *file, int line,
        const char *func, const char *expr) {
    printf("%s:%d: assertion \"%s\" failed\n", file, line, expr);
    __box_abort(-1);
}

__attribute__((noreturn))
void _exit(int returncode) {
    if (returncode > 0) {
        returncode = -returncode;
    }

    __box_abort(returncode);
}
#endif

//// __box_write glue ////

int __box_flush(int32_t fd) {
    return 0;
}

ssize_t __box_cbprintf(
        ssize_t (*write)(void *ctx, const void *buf, size_t size), void *ctx,
        const char *format, va_list args) {
    const char *p = format;
    ssize_t res = 0;
    while (true) {
        // first consume everything until a '%'
        size_t skip = strcspn(p, "%");
        if (skip > 0) {
            ssize_t nres = write(ctx, p, skip);
            if (nres < 0) {
                return nres;
            }
            res += nres;
        }

        p += skip;

        // hit end of string?
        if (!*p) {
            return res;
        }

        // format parser
        bool zero_justify = false;
        bool left_justify = false;
        bool precision_mode = false;
        size_t width = 0;
        size_t precision = 0;

        char mode = 'c';
        uint32_t value = 0;
        size_t size = 0;

        for (;; p++) {
            if (p[1] >= '0' && p[1] <= '9') {
                // precision/width
                if (precision_mode) {
                    precision = precision*10 + (p[1]-'0');
                } else if (p[1] > '0' || width > 0) {
                    width = width*10 + (p[1]-'0');
                } else {
                    zero_justify = true;
                }

            } else if (p[1] == '*') {
                // dynamic precision/width
                if (precision_mode) {
                    precision = va_arg(args, size_t);
                } else {
                    width = va_arg(args, size_t);
                }

            } else if (p[1] == '.') {
                // switch mode
                precision_mode = true;

            } else if (p[1] == '-') {
                // left-justify
                left_justify = true;

            } else if (p[1] == '%') {
                // single '%'
                mode = 'c';
                value = '%';
                size = 1;
                break;

            } else if (p[1] == 'c') {
                // char
                mode = 'c';
                value = va_arg(args, int);
                size = 1;
                break;

            } else if (p[1] == 's') {
                // string
                mode = 's';
                const char *s = va_arg(args, const char *);
                value = (uint32_t)s;
                // find size, don't allow overruns
                size = 0;
                while (s[size] && (precision == 0 || size < precision)) {
                    size += 1;
                }
                break;

            } else if (p[1] == 'd' || p[1] == 'i') {
                // signed decimal number
                mode = 'd';
                int32_t d = va_arg(args, int32_t);
                value = (uint32_t)d;
                size = 0;
                if (d < 0) {
                    size += 1;
                    d = -d;
                }
                for (uint32_t t = d; t > 0; t /= 10) {
                    size += 1;
                }
                if (size == 0) {
                    size += 1;
                }
                break;

            } else if (p[1] == 'u') {
                // unsigned decimal number
                mode = 'u';
                value = va_arg(args, uint32_t);
                size = 0;
                for (uint32_t t = value; t > 0; t /= 10) {
                    size += 1;
                }
                if (size == 0) {
                    size += 1;
                }
                break;

            } else if (p[1] >= ' ' && p[1] <= '?') {
                // unknown modifier? skip

            } else {
                // hex or unknown character, terminate

                // make it prettier for pointers
                if (!(p[1] == 'x' || p[1] == 'X')) {
                    zero_justify = true;
                    width = 2*sizeof(void*);
                }

                // hexadecimal number
                mode = 'x';
                value = va_arg(args, uint32_t);
                size = 0;
                for (uint32_t t = value; t > 0; t /= 16) {
                    size += 1;
                }
                if (size == 0) {
                    size += 1;
                }
                break;
            }
        }

        // consume the format
        p += 2;

        // format printing
        if (!left_justify) {
            for (ssize_t i = 0; i < (ssize_t)width-(ssize_t)size; i++) {
                char c = (zero_justify) ? '0' : ' ';
                ssize_t nres = write(ctx, &c, 1);
                if (nres < 0) {
                    return nres;
                }
                res += nres;
            }
        }

        if (mode == 'c') {
            ssize_t nres = write(ctx, &value, 1);
            if (nres < 0) {
                return nres;
            }
            res += nres;
        } else if (mode == 's') {
            ssize_t nres = write(ctx, (const char*)(uintptr_t)value, size);
            if (nres < 0) {
                return nres;
            }
            res += nres;
        } else if (mode == 'x') {
            for (ssize_t i = size-1; i >= 0; i--) {
                uint32_t digit = (value >> (4*i)) & 0xf;

                char c = ((digit >= 10) ? ('a'-10) : '0') + digit;
                ssize_t nres = write(ctx, &c, 1);
                if (nres < 0) {
                    return nres;
                }
                res += nres;
            }
        } else if (mode == 'd' || mode == 'u') {
            ssize_t i = size-1;

            if (mode == 'd' && (int32_t)value < 0) {
                ssize_t nres = write(ctx, "-", 1);
                if (nres < 0) {
                    return nres;
                }
                res += nres;

                value = -value;
                i -= 1;
            }

            for (; i >= 0; i--) {
                uint32_t temp = value;
                for (int j = 0; j < i; j++) {
                    temp /= 10;
                }
                uint32_t digit = temp % 10;

                char c = '0' + digit;
                ssize_t nres = write(ctx, &c, 1);
                if (nres < 0) {
                    return nres;
                }
                res += nres;
            }
        }

        if (left_justify) {
            for (ssize_t i = 0; i < (ssize_t)width-(ssize_t)size; i++) {
                char c = ' ';
                ssize_t nres = write(ctx, &c, 1);
                if (nres < 0) {
                    return nres;
                }
                res += nres;
            }
        }
    }
}

static ssize_t __box_vprintf_write(void *ctx, const void *buf, size_t size) {
    return __box_write((int32_t)ctx, buf, size);
}

__attribute__((used))
ssize_t __wrap_vprintf(const char *format, va_list args) {
    return __box_cbprintf(__box_vprintf_write, (void*)1, format, args);
}

__attribute__((used))
ssize_t __wrap_printf(const char *format, ...) {
    va_list args;
    va_start(args, format);
    ssize_t res = __wrap_vprintf(format, args);
    va_end(args);
    return res;
}

__attribute__((used))
ssize_t __wrap_vfprintf(FILE *f, const char *format, va_list args) {
    int32_t fd = (f == stdout) ? 1 : 2;
    return __box_cbprintf(__box_vprintf_write, (void*)fd, format, args);
}

__attribute__((used))
ssize_t __wrap_fprintf(FILE *f, const char *format, ...) {
    va_list args;
    va_start(args, format);
    ssize_t res = __wrap_vfprintf(f, format, args);
    va_end(args);
    return res;
}

__attribute__((used))
int __wrap_fflush(FILE *f) {
    int32_t fd = (f == stdout) ? 1 : 2;
    return __box_flush(fd);
}

#ifdef __GNUC__
int _write(int handle, const char *buffer, int size) {
    return __box_write(handle, (const uint8_t*)buffer, size);
}
#endif

//// ISR Vector definitions ////

extern void main(void);

// Reset Handler
__attribute__((naked, noreturn))
int32_t __box_reset_handler(void) {
    // load data
    extern uint32_t __data_init_start;
    extern uint32_t __data_start;
    extern uint32_t __data_end;
    const uint32_t *s = &__data_init_start;
    for (uint32_t *d = &__data_start; d < &__data_end; d++) {
        *d = *s++;
    }

    // zero bss
    extern uint32_t __bss_start;
    extern uint32_t __bss_end;
    for (uint32_t *d = &__bss_start; d < &__bss_end; d++) {
        *d = 0;
    }

    // init libc
    extern void __libc_init_array(void);
    __libc_init_array();

    // enter main
    main();

    // halt if main exits
    while (1) {
        __asm__ volatile ("wfi");
    }
}

//// Default handlers ////

__attribute__((naked, noreturn))
void __box_nmi_handler(void) {
    while (1) {}
}

__attribute__((naked, noreturn))
void __box_hardfault_handler(void) {
    while (1) {}
}

__attribute__((naked, noreturn))
void __box_svc_handler(void) {
    while (1) {}
}

__attribute__((naked, noreturn))
void __box_debugmon_handler(void) {
    while (1) {}
}

__attribute__((naked, noreturn))
void __box_pendsv_handler(void) {
    while (1) {}
}

__attribute__((naked, noreturn))
void __box_systick_handler(void) {
    while (1) {}
}

__attribute__((naked, noreturn))
void __box_default_handler(void) {
    while (1) {}
}

void __box_memmanage_handler(void);
void __box_busfault_handler(void);
void __box_usagefault_handler(void);

extern uint32_t __stack_end;

//// ISR Vector ////

__attribute__((used, section(".isr_vector")))
const uint32_t __isr_vector[256] = {
    (uint32_t)&__stack_end,
    (uint32_t)&__box_reset_handler,
    // Exception handlers
    (uint32_t)__box_nmi_handler,
    (uint32_t)__box_hardfault_handler,
    (uint32_t)__box_memmanage_handler,
    (uint32_t)__box_busfault_handler,
    (uint32_t)__box_usagefault_handler,
    (uint32_t)0,
    (uint32_t)0,
    (uint32_t)0,
    (uint32_t)0,
    (uint32_t)__box_svc_handler,
    (uint32_t)__box_debugmon_handler,
    (uint32_t)0,
    (uint32_t)__box_pendsv_handler,
    (uint32_t)__box_systick_handler,
    // External IRQ handlers
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
    (uint32_t)__box_default_handler,
};

//// box1 loading ////

static int __box_box1_load(void) {
    // default loader does nothing
    return 0;
}

//// box1 state ////
struct __box_state __box_box1_state;
extern uint32_t __box_box1_jumptable[];

const struct __box_mpuregions __box_box1_mpuregions = {
    .control = 1,
    .count = 2,
    .regions = {
        {0x000fe000, 0x02000019},
        {0x2003e000, 0x13000019},
    },
};

//// box1 exports ////

int32_t box1_add2(int32_t a0, int32_t a1) {
    if (!__box_box1_state.initialized) {
        int err = __box_box1_init();
        if (err) {
            return err;
        }
    }

    extern int32_t __box_import_box1_add2(int32_t a0, int32_t a1);
    return __box_import_box1_add2(a0, a1);
}

int box1_badassert(void) {
    if (!__box_box1_state.initialized) {
        int err = __box_box1_init();
        if (err) {
            return err;
        }
    }

    extern int __box_import_box1_badassert(void);
    return __box_import_box1_badassert();
}

int box1_badread(void) {
    if (!__box_box1_state.initialized) {
        int err = __box_box1_init();
        if (err) {
            return err;
        }
    }

    extern int __box_import_box1_badread(void);
    return __box_import_box1_badread();
}

int box1_badwrite(void) {
    if (!__box_box1_state.initialized) {
        int err = __box_box1_init();
        if (err) {
            return err;
        }
    }

    extern int __box_import_box1_badwrite(void);
    return __box_import_box1_badwrite();
}

int box1_hello(void) {
    if (!__box_box1_state.initialized) {
        int err = __box_box1_init();
        if (err) {
            return err;
        }
    }

    extern int __box_import_box1_hello(void);
    return __box_import_box1_hello();
}

int box1_overflow(void) {
    if (!__box_box1_state.initialized) {
        int err = __box_box1_init();
        if (err) {
            return err;
        }
    }

    extern int __box_import_box1_overflow(void);
    return __box_import_box1_overflow();
}

//// box1 imports ////

// redirect __box_box1_write -> __box_write
#define __box_box1_write __box_write

// redirect __box_box1_flush -> __box_flush
#define __box_box1_flush __box_flush

const uint32_t __box_box1_sys_jumptable[] = {
    (uint32_t)__box_box1_write,
    (uint32_t)__box_box1_flush,
};

//// box1 init ////

int __box_box1_init(void) {
    int err;
    // make sure that the MPU is initialized
    err = __box_mpu_init();
    if (err) {
        return err;
    }

    // prepare the box's stack
    // must use PSP, otherwise boxes could overflow the ISR stack
    __box_box1_state.lr = 0xfffffffd; // TODO determine fp?
    __box_box1_state.sp = (void*)__box_box1_jumptable[0];

    // load the box if unloaded
    err = __box_box1_load();
    if (err) {
        return err;
    }

    // call box's init
    extern int __box_box1_postinit(void);
    err = __box_box1_postinit();
    if (err) {
        return err;
    }

    __box_box1_state.initialized = true;
    return 0;
}

int __box_box1_clobber(void) {
    __box_box1_state.initialized = false;
    return 0;
}

void *__box_box1_push(size_t size) {
    size = (size+3)/4;
    extern uint8_t __box_box1_ram_start;
    if (__box_box1_state.sp - size < (uint32_t*)&__box_box1_ram_start) {
        return NULL;
    }

    __box_box1_state.sp -= size;
    return __box_box1_state.sp;
}

void __box_box1_pop(size_t size) {
    size = (size+3)/4;
    __attribute__((unused))
    extern uint8_t __box_box1_ram_end;
    assert(__box_box1_state.sp + size <= (uint32_t*)&__box_box1_ram_end);
    __box_box1_state.sp += size;
}

struct __box_state __box_sys_state;

struct __box_state *const __box_state[__BOX_COUNT+1] = {
    &__box_sys_state,
    &__box_box1_state,
};

void (*const __box_aborts[])(int err) = {
    NULL,
    NULL,
};

const struct __box_mpuregions __box_sys_mpuregions = {
    .control = 0,
    .count = 0,
    .regions = {}
};

const struct __box_mpuregions *const __box_mpuregions[__BOX_COUNT+1] = {
    &__box_sys_mpuregions,
    &__box_box1_mpuregions,
};

const uint32_t *const __box_jumptables[__BOX_COUNT] = {
    __box_box1_jumptable,
};

const uint32_t *const __box_sys_jumptables[__BOX_COUNT] = {
    __box_box1_sys_jumptable,
};

struct __box_frame {
    uint32_t *fp;
    uint32_t lr;
    uint32_t *sp;
    uint32_t caller;
};

// foward declaration of fault wrapper, may be called directly
// in other handlers, but only in other handlers! (needs isr context)
uint64_t __box_faultsetup(int32_t err) {
    // mark box as uninitialized
    __box_state[__box_active]->initialized = false;

    // invoke user handler, should not return
    // TODO should we set this up to be called in non-isr context?
    if (__box_aborts[__box_active]) {
        __box_aborts[__box_active](err);
        __builtin_unreachable();
    }

    struct __box_state *state = __box_state[__box_active];
    struct __box_state *targetstate = __box_state[state->caller];
    uint32_t targetlr = targetstate->lr;
    uint32_t *targetsp = targetstate->sp;
    struct __box_frame *targetbf = (struct __box_frame*)targetsp;
    uint32_t *targetfp = targetbf->fp;
    // in call?
    if (!targetlr) {
        // halt if we can't handle
        __box_abort(-ELOOP);
    }

    // check if our return target supports erroring
    uint32_t op = targetfp[6];
    if (!(op & 2)) {
        // halt if we can't handle
        __box_abort(err);
    }

    // we can return an error
    __box_active = state->caller;
    targetstate->lr = targetbf->lr;
    targetstate->sp = targetbf->sp;
    targetstate->caller = targetbf->caller;

    // select MPU regions
    __box_mpu_switch(__box_mpuregions[__box_active]);

    // copy return frame
    targetfp[0] = err;         // r0 = arg0
    targetfp[1] = 0;           // r1 = arg1
    targetfp[2] = 0;           // r2 = arg2
    targetfp[3] = 0;           // r3 = arg3
    targetfp[6] = targetfp[5]; // pc = lr

    return ((uint64_t)targetlr) | ((uint64_t)(uint32_t)targetsp << 32);
}

__attribute__((naked, noreturn))
void __box_faulthandler(int32_t err) {
    __asm__ volatile (
        // call into c with stack control
        "bl __box_faultsetup \n\t"
        // drop saved state
        "add r1, r1, #4*4 \n\t"
        // restore fp registers?
        "tst r0, #0x10 \n\t"
        "it eq \n\t"
        "vldmiaeq r1!, {s16-s31} \n\t"
        // restore core registers
        "ldmia r1!, {r4-r11} \n\t"
        // update sp
        "tst r0, #0x4 \n\t"
        "ite eq \n\t"
        "msreq msp, r1 \n\t"
        "msrne psp, r1 \n\t"
        // return
        "bx r0 \n\t"
        ::
        "i"(__box_faultsetup)
    );
}

uint64_t __box_callsetup(uint32_t lr, uint32_t *sp,
        uint32_t op, uint32_t *fp) {
    // save lr + sp
    struct __box_state *state = __box_state[__box_active];
    struct __box_frame *frame = (struct __box_frame*)sp;
    frame->fp = fp;
    frame->lr = state->lr;
    frame->sp = state->sp;
    frame->caller = state->caller;
    state->lr = lr;
    state->sp = sp;

    uint32_t caller = __box_active;
    __box_active = (caller == 0)
        ? (((op/4)-2) % __BOX_COUNT) + 1
        : 0;
    uint32_t targetpc = (caller == 0)
        ? __box_jumptables[__box_active-1][((op/4)-2) / __BOX_COUNT + 1]
        : __box_sys_jumptables[caller-1][((op/4)-2)];
    struct __box_state *targetstate = __box_state[__box_active];
    uint32_t targetlr = targetstate->lr;
    uint32_t *targetsp = targetstate->sp;
    // keep track of caller
    targetstate->caller = caller;
    // don't allow returns while executing
    targetstate->lr = 0;
    // need sp to fixup instruction aborts
    targetstate->sp = targetsp;

    // select MPU regions
    __box_mpu_switch(__box_mpuregions[__box_active]);

    // setup new call frame
    targetsp -= 8;
    targetsp[0] = fp[0];        // r0 = arg0
    targetsp[1] = fp[1];        // r1 = arg1
    targetsp[2] = fp[2];        // r2 = arg2
    targetsp[3] = fp[3];        // r3 = arg3
    targetsp[4] = fp[4];        // r12 = r12
    targetsp[5] = (uint32_t)&__box_return; // lr = __box_return
    targetsp[6] = targetpc;     // pc = targetpc
    targetsp[7] = fp[7];        // psr = psr

    return ((uint64_t)targetlr) | ((uint64_t)(uint32_t)targetsp << 32);
}

__attribute__((naked))
void __box_callhandler(uint32_t lr, uint32_t *sp, uint32_t op) {
    __asm__ volatile (
        // keep track of args
        "mov r3, r1 \n\t"
        // save core registers
        "stmdb r1!, {r4-r11} \n\t"
        // save fp registers?
        "tst r0, #0x10 \n\t"
        "it eq \n\t"
        "vstmdbeq r1!, {s16-s31} \n\t"
        // make space to save state
        "sub r1, r1, #4*4 \n\t"
        // sp == msp?
        "tst r0, #0x4 \n\t"
        "it eq \n\t"
        "moveq sp, r1 \n\t"
        // ah! reserve a frame in case we're calling this
        // interrupts stack from another stack
        "sub sp, sp, #8*4 \n\t"
        // call into c now that we have stack control
        "bl __box_callsetup \n\t"
        // update new sp
        "tst r0, #0x4 \n\t"
        "itee eq \n\t"
        "msreq msp, r1 \n\t"
        "msrne psp, r1 \n\t"
        // drop reserved frame?
        "addne sp, sp, #8*4 \n\t"
        // return to call
        "bx r0 \n\t"
        ::
        "i"(__box_callsetup)
    );
}

uint64_t __box_returnsetup(uint32_t lr, uint32_t *sp,
        uint32_t op, uint32_t *fp) {
    // save lr + sp
    struct __box_state *state = __box_state[__box_active];
    // drop exception frame and fixup instruction aborts
    sp = state->sp;
    state->lr = lr;
    state->sp = sp;

    __box_active = state->caller;

    struct __box_state *targetstate = __box_state[__box_active];
    uint32_t targetlr = targetstate->lr;
    // in call?
    if (!targetlr) {
        __box_faulthandler(-EFAULT);
        __builtin_unreachable();
    }
    uint32_t *targetsp = targetstate->sp;
    struct __box_frame *targetframe = (struct __box_frame*)targetsp;
    uint32_t *targetfp = targetframe->fp;
    targetstate->lr = targetframe->lr;
    targetstate->sp = targetframe->sp;
    targetstate->caller = targetframe->caller;

    // select MPU regions
    __box_mpu_switch(__box_mpuregions[__box_active]);

    // copy return frame
    targetfp[0] = fp[0];       // r0 = arg0
    targetfp[1] = fp[1];       // r1 = arg1
    targetfp[2] = fp[2];       // r2 = arg2
    targetfp[3] = fp[3];       // r3 = arg3
    targetfp[6] = targetfp[5]; // pc = lr

    return ((uint64_t)targetlr) | ((uint64_t)(uint32_t)targetsp << 32);
}

__attribute__((naked, noreturn))
void __box_returnhandler(uint32_t lr, uint32_t *sp, uint32_t op) {
    __asm__ volatile (
        // keep track of rets
        "mov r3, r1 \n\t"
        // call into c new that we have stack control
        "bl __box_returnsetup \n\t"
        // drop saved state
        "add r1, r1, #4*4 \n\t"
        // restore fp registers?
        "tst r0, #0x10 \n\t"
        "it eq \n\t"
        "vldmiaeq r1!, {s16-s31} \n\t"
        // restore core registers
        "ldmia r1!, {r4-r11} \n\t"
        // update sp
        "tst r0, #0x4 \n\t"
        "ite eq \n\t"
        "msreq msp, r1 \n\t"
        "msrne psp, r1 \n\t"
        // return
        "bx r0 \n\t"
        ::
        "i"(__box_returnsetup)
    );
}

__attribute__((alias("__box_mpu_handler")))
void __box_usagefault_handler(void);
__attribute__((alias("__box_mpu_handler")))
void __box_busfault_handler(void);
__attribute__((alias("__box_mpu_handler")))
void __box_memmanage_handler(void);
__attribute__((naked))
void __box_mpu_handler(void) {
    __asm__ volatile (
        // get lr
        "mov r0, lr \n\t"
        "tst r0, #0x4 \n\t"
        // get sp
        "ite eq \n\t"
        "mrseq r1, msp \n\t"
        "mrsne r1, psp \n\t"
        // get pc
        "ldr r2, [r1, #6*4] \n\t"

        // check type of call
        // return?
        "ldr r3, =__box_callregion \n\t"
        "subs r2, r2, r3 \n\t"
        "beq __box_returnhandler \n\t"

        // explicit abort?
        "cmp r2, #4 \n\t"
        "itt eq \n\t"
        "ldreq r0, [r1, #0] \n\t"
        "beq __box_faulthandler \n\t"

        // call?
        "ldr r3, =1048576 \n\t"
        "cmp r2, r3 \n\t"
        "blo __box_callhandler \n\t"

        // if we've reached here this is a true fault
        "ldr r0, =%[EFAULT] \n\t"
        "b __box_faulthandler \n\t"
        "b ."
        ::
        "i"(__box_faulthandler),
        "i"(__box_callhandler),
        "i"(__box_returnhandler),
        "i"(&__box_callregion),
        [EFAULT]"i"(-EFAULT)
    );
}

