    def box_parent(self, parent, box):
        assert math.log2(self._call_region.size) % 1 == 0, (
            "MPU call region is not aligned to a power-of-two %s"
                % self._call_region)
        assert self._call_region.addr % self._call_region.size == 0, (
            "MPU call region is not aligned to size %s"
                % self._call_region)
        self.pushattrs(
            callprefix=self._call_region.addr,
            callmask=(self._call_region.size//2)-1,
            retprefix=self._call_region.addr + self._call_region.size//2,
            retmask=(self._call_region.size//2)-1,
            callregionaddr=self._call_region.addr,
            callregionsize=self._call_region.size,
            callregionlog2=int(math.log2(self._call_region.size)),
            mpuregions=self._mpu_regions)

        for box in parent.boxes:
            if box.runtime == self:
                for memory in box.memories:
                    assert math.log2(memory.size) % 1 == 0, (
                        "Memory region %s not aligned to a power-of-two"
                            % memory.name)
                    assert memory.addr % memory.size == 0, (
                        "Memory region %s not aligned to its size"
                            % memory.name)
                    assert memory.size >= 32, (
                        "Memory region %s too small (< 32 bytes)"
                            % memory.name)

        self.ids = {}

        for j, export in enumerate(it.chain(
                ['__box_write'],
                (export.name for export in parent.exports))):
            self.ids[export] = j*(len(parent.boxes)+1)

        for i, box in enumerate(parent.boxes):
            # TODO make unique name?
            self.ids['box ' + box.name] = i+1
            for j, export in enumerate(it.chain(
                    ['__box_%s_rawinit' % box.name],
                    (export.name for export in box.exports))):
                self.ids[export] = j*(len(parent.boxes)+1) + i+1
