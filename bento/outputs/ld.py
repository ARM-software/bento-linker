from .. import outputs
from ..box import Memory
import io
import textwrap
import itertools as it

def buildmemory(outf, memory):
    outf.pushattrs(
        prefix=outf.get('prefix', ''),
        memory='%(prefix)s' + memory.name,
        mode=''.join(sorted(memory.mode)),
        addr=memory.addr,
        size=memory.size)
    outf.writef('%(MEMORY)-16s (%(MODE)-3s) : '
        'ORIGIN = %(addr)#010x, '
        'LENGTH = %(size)#010x')

def buildsymbol(outf, symbol):
    outf.pushattrs(
        symbol=symbol[0],
        addr=symbol[1])
    outf.writef('%(symbol)-24s = ')
    if outf.get('cond', False):
        outf.writef('DEFINED(%(symbol)s) ? %(symbol)s : ')
    try:
        outf.writef('%(addr)#010x;')
    except TypeError:
        outf.writef('%(addr)s;')

@outputs.output
class PartialLDOutput(outputs.Output):
    """
    Name of file to target for a partial linkerscript. This is the minimal
    additions needed for a bento box and should be imported into a traditional
    linkerscript to handle the normal program sections.
    """
    __argname__ = "partial_ld"
    __arghelp__ = __doc__

    def __init__(self, path=None):
        super().__init__(path)
        self.decls = outputs.OutputField(self, {tuple: buildsymbol})
        self.memories = outputs.OutputField(self, {Memory: buildmemory},
            indent=4,
            memory=None,
            mode='rwx',
            addr=0,
            size=0)
        self.sections = outputs.OutputField(self,
            indent=4,
            section=None,
            memory=None,
            align=4)

    def default_build_parent(self, parent, box):
        # create memories + sections for subboxes?
        for memory in box.memories:
            self.memories.append(memory, prefix='box_%(box)s_')

            outf = self.sections.append(
                section='.box.%(box)s.' + memory.name,
                memory='box_%(box)s_' + memory.name)
            outf.writef('%(section)s : {\n')
            with outf.pushindent():
                # TODO prefixes considered harmful?
                outf.writef('__%(memory)s = .;\n')
                outf.writef('KEEP(*(%(section)s*))\n')
                outf.writef('. = ORIGIN(%(MEMORY)s) + '
                    'LENGTH(%(MEMORY)s);\n')
                outf.writef('__%(memory)s_end = .;\n')
            outf.writef('} > %(MEMORY)s')

    def build(self, box):
        # TODO docs?
        self.write('/***** AUTOGENERATED *****/\n')
        self.write('\n')
        if self.decls:
            for decl in self.decls:
                self.write(decl.getvalue())
                self.write('\n')
            self.write('\n')
        if self.memories:
            self.write('MEMORY {\n')
            # order memories based on address
            for memory in sorted(self.memories, key=lambda m: m['addr']):
                if memory['mode']:
                    self.write(memory.getvalue())
                    self.write('\n')
            self.write('}\n')
            self.write('\n')
        if self.sections:
            self.write('SECTIONS {\n')
            # order sections based on memories' address
            sections = self.sections
            for memory in sorted(self.memories, key=lambda m: m['addr']):
                if any(section['memory'] == memory['memory']
                        for section in sections):
                    self.write('    /* %s sections */\n'
                        % memory['memory'].upper())
                nsections = []
                for section in sections:
                    if section['memory'] == memory['memory']:
                        self.write(section.getvalue())
                        self.write('\n\n')
                    else:
                        nsections.append(section)
                sections = nsections
            # write any sections without a valid memory?
            if sections:
                self.write('    /* misc sections */\n')
                for section in sections:
                    self.write(section.getvalue())
                    self.write('\n\n')
            self.write('}\n')
            self.write('\n')

@outputs.output
class LDOutput(PartialLDOutput):
    """
    Name of file to target for the linkerscript.
    """
    __argname__ = "ld"
    __arghelp__ = __doc__

    def default_build(self, box):
        for memory in box.memories:
            for slice in memory - it.chain.from_iterable(
                    subbox.memories for subbox in box.boxes):
                self.memories.append(slice)

        if box.issys():
            self.decls.insert(0, 'ENTRY(Reset_Handler)')

        # write out rom sections
        # need interrupt vector?
        if box.issys() and box.isr_vector:
            memory, _, _ = box.consume('rx', section=box.isr_vector)
            self.decls.append(('__isr_vector_min', box.isr_vector.size),
                cond=True)
            outf = self.sections.append(
                section='.isr_vector',
                memory=memory.name)
            outf.writef('.isr_vector : {\n')
            with outf.pushindent():
                outf.writef('. = ALIGN(%(align)d);\n')
                outf.writef('__isr_vector = .;\n')
                outf.writef('KEEP(*(.isr_vector))\n')
                outf.writef('. = __isr_vector +'
                    '__isr_vector_min;\n')
                outf.writef('. = ALIGN(%(align)d);\n')
                outf.writef('__isr_vector_end = .;\n')
            outf.writef('} > %(MEMORY)s')

        memory, _, _ = box.consume('rx', section=box.text)
        outf = self.sections.append(
            section='.text',
            memory=memory.name)
        outf.writef('%(section)s : {\n')
        with outf.pushindent():
            outf.writef('. = ALIGN(%(align)d);\n')
            outf.writef('__text = .;\n')
            outf.writef('*(.text*)\n')
            outf.writef('*(.rodata*)\n')
            outf.writef('*(.glue_7*)\n')
            outf.writef('*(.glue_7t*)\n')
            outf.writef('*(.eh_frame*)\n')
            outf.writef('KEEP(*(.init*))\n')
            outf.writef('KEEP(*(.fini*))\n') # TODO oh boy there's a lot of other things
            outf.writef('. = ALIGN(%(align)d);\n')
            outf.writef('__text_end = .;\n')
            outf.writef('__data_init = .;\n')
        outf.writef('} > %(MEMORY)s')

        # writef out ram sections
        if box.stack:
            memory, _, _ = box.consume('rw', section=box.stack)
            self.decls.append(('__stack_min', box.stack.size),
                cond=True)
            outf = self.sections.append(
                section='.stack',
                memory=memory.name)
            outf.writef('%(section)s (NOLOAD) : {\n')
            with outf.pushindent():
                outf.writef('. = ALIGN(%(align)d);\n')
                outf.writef('__stack = .;\n')
                outf.writef('. += __stack_min;\n')
                outf.writef('. = ALIGN(%(align)d);\n')
                outf.writef('__stack_end = .;\n')
            outf.writef('} > %(MEMORY)s')

        memory, _, _ = box.consume('rw', section=box.data)
        outf = self.sections.append(
            section='.data',
            memory=memory.name)
        outf.writef('%(section)s : AT(__data_init) {\n')
        with outf.pushindent():
            outf.writef('. = ALIGN(%(align)d);\n')
            outf.writef('__data = .;\n')
            outf.writef('*(.data*)\n')
            outf.writef('. = ALIGN(%(align)d);\n')
            outf.writef('__data_end = .;\n')
        outf.writef('} > %(MEMORY)s')

        memory, _, _ = box.consume('rw', section=box.bss)
        outf = self.sections.append(
            section='.bss',
            memory=memory.name)
        outf.writef('%(section)s (NOLOAD) : {\n')
        with outf.pushindent():
            outf.writef('. = ALIGN(%(align)d);\n')
            outf.writef('__bss = .;\n')
            # TODO hm
            outf.writef('__bss_start__ = .;\n')
            outf.writef('*(.bss*)\n')
            outf.writef('*(COMMON)\n')
            outf.writef('. = ALIGN(%(align)d);\n')
            outf.writef('__bss_end = .;\n')
            outf.writef('__bss_end__ = .;\n')
        outf.writef('} > %(MEMORY)s')

        if box.heap:
            memory, _, _ = box.consume('rw', section=box.heap)
            self.decls.append(('__heap_min', box.heap.size),
                cond=True)
            outf = self.sections.append(
                section='.heap',
                memory=memory.name)
            outf.writef('%(section)s (NOLOAD) : {\n')
            with outf.pushindent():
                outf.writef('. = ALIGN(%(align)d);\n')
                outf.writef('__end__ = .;\n')
                outf.writef('PROVIDE(end = .);\n')
                outf.writef('__heap = .;\n')
                # TODO need all these?
                outf.writef('__HeapBase = .;\n')
                outf.writef('. += ORIGIN(%(MEMORY)s) + LENGTH(%(MEMORY)s);\n')
                outf.writef('. = ALIGN(%(align)d);\n')
                outf.writef('__heap_end = .;\n')
                # TODO need all these?
                outf.writef('__HeapLimit = .;\n')
                outf.writef('__heap_limit = .;\n')
            outf.writef('} > %(MEMORY)s\n')
            outf.writef('ASSERT(__heap_end - __heap > __heap_min,\n')
            outf.writef('    "Not enough memory for heap")')
