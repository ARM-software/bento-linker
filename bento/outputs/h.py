from .. import outputs
from ..box import Fn
import io
import textwrap

@outputs.output
class HOutput(outputs.Output):
    """
    Name of header file to generate containing the imported functions.
    """
    __argname__ = "h"
    __arghelp__ = __doc__

    def __init__(self, path=None):
        super().__init__(path)

        def buildinclude(out, include):
            if not (include.startswith('"') or include.startswith('<')):
                include = '"%s"' % include
            out.writef(include)

        def buildfn(out, fn):
            if fn.doc:
                out.pushattrs(doc=fn.doc)
            if out.get('attrs', False):
                out.writef('%(attrs)s ')
            out.writef('%(fn)s;', fn=fn.repr_c())

        self.includes = outputs.OutputField(self, {str: buildinclude})
        self.decls = outputs.OutputField(self, {Fn: buildfn})

    def box(self, box):
        super().box(box)
        self.pushattrs(gaurd='__BOX_%(BOX)s_H')

    def default_build_box_prologue(self, box):
        # always need standard types
        self.includes.append("<sys/types.h>")

        # TODO configurable?
        out = self.decls.append()
        out.printf('//// box error codes ////')
        out.printf('enum box_err {')
        with out.indent():
            for name, code, doc in [
                ('BOX_ERR_OK',       0,    'No error'),
                ('BOX_ERR_NOBOX',    -8,   'Box format error'),
                ('BOX_ERR_AGAIN',    -11,  'Try again'),
                ('BOX_ERR_NOMEM',    -12,  'Cannot allocate memory'),
                ('BOX_ERR_FAULT',    -14,  'Bad address'),
                ('BOX_ERR_BUSY',     -16,  'Device or resource busy'),
                ('BOX_ERR_LOOP',     -20,  'Cyclic data structure detected'),
                ('BOX_ERR_INVAL',    -22,  'Invalid parameter'),
                ('BOX_ERR_TIMEDOUT', -110, 'Timed out')]:
                out.printf('%(name)-24s = %(code)-5s // %(doc)s',
                    name=name,
                    code='%s,' % code,
                    doc=doc)
        out.printf('};')

        # TODO always have this?
        if box.boxes:
            self.decls.append('//// box hooks ////')
            for subbox in box.boxes:
                with self.pushattrs(box=subbox.name):
                    self.decls.append(
                        'int32_t __box_%(box)s_init(void);',
                        doc='box %(box)s initialization')
                    # TODO handle this differently?
                    # TODO use setter?
                    # TODO expect export?
                    self.decls.append(
                        'extern void '
                        '__box_%(box)s_fault_handler(uint32_t addr);',
                        doc='function to call on bad address')

        if box.imports:
            self.decls.append('//// box imports ////')
            for import_ in box.imports:
                self.decls.append(import_)
        if box.exports:
            self.decls.append('//// box exports ////')
            for export in box.exports:
                self.decls.append(export, attrs='extern')

    def build(self, box):
        self.write('////// AUTOGENERATED //////\n')
        self.write('#ifndef %(gaurd)s\n' % self)
        self.write('#define %(gaurd)s\n' % self)
        includes = set()
        for include in self.includes:
            includes.add(include.getvalue())
        for include in sorted(includes):
            self.write('#include %s\n' % include)
        self.write('\n')

        for decl in self.decls:
            if 'doc' in decl:
                for line in textwrap.wrap(decl['doc'], width=77):
                    self.write('// %s\n' % line)
            self.write(decl.getvalue().strip())
            self.write('\n\n')

        self.write('\n')
        self.write('#endif\n')
    
