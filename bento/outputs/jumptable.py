from .. import outputs
from ..box import Fn
from .header import buildinclude, buildfn, HeaderGlueOutput_
import io
import textwrap

@outputs.output('sys')
@outputs.output('box')
class JumptableOutput(outputs.Output):
    """
    Name of source file to target for building a jumptable.
    """
    __argname__ = "c_glue"
    __arghelp__ = __doc__

    def __init__(self, sys, box, path):
        self._includes = []
        self._decls = []
        super().__init__(sys, box, path)

    def append_include(self, fmt=None, **kwargs):
        include = fmt % self.mkformat(**kwargs)
        if not include.startswith('"') and not include.startswith('<'):
            include = '"%s"' % include
        if include not in self._includes:
            self._includes.append(include)

    def append_decl(self, fmt=None, **kwargs):
        outf = self.mkfield(**kwargs)
        self._decls.append(outf)
        if fmt is not None:
            outf.write(fmt)
        return outf

    def build(self, outf):
        outf.write('////// AUTOGENERATED //////\n')
        for include in self._includes:
            outf.write('#include %s\n' % include)
        outf.write('\n')
        for decl in self._decls:
            outf.write(decl.getvalue())
            outf.write('\n')

@outputs.output('sys')
@outputs.output('box')
class CGlueOutput_(outputs.Output_):
    """
    Name of source file to target for building a jumptable.
    """
    __argname__ = "c_glue_"
    __arghelp__ = __doc__

    def __init__(self, box, path=None):
        super().__init__(box, path)
        self.includes = outputs.OutputField_(self, rules={str: buildinclude})
        self.decls = outputs.OutputField_(self, rules={Fn: buildfn})

        # create temporary header type to get implicit definitions
        header = HeaderGlueOutput_(box)
        self.includes.extend(header.includes)
        self.decls.extend(header.decls)

    def build(self, outf):
        outf.write('////// AUTOGENERATED //////\n')
        includes = set()
        for include in self.includes:
            includes.add(include.getvalue())
        for include in sorted(includes):
            outf.write('#include %s\n' % include)
        outf.write('\n')

        for decl in self.decls:
            if decl.getvalue().startswith(4*'/'):
                outf.write('\n')
            if decl.get('doc', None) is not None:
                for line in textwrap.wrap(decl['doc'] % decl, width=77):
                    outf.write('// %s\n' % line)
            outf.write(decl.getvalue().strip())
            outf.write('\n\n')
